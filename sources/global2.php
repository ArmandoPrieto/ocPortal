<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * Standard code module initialisation function.
 */
function init__global2()
{
	global $BOOTSTRAPPING,$CHECKING_SAFEMODE,$BROWSER_DECACHEING_CACHE,$CHARSET_CACHE,$TEMP_CHARSET_CACHE,$RELATIVE_PATH,$CURRENTLY_HTTPS_CACHE,$RUNNING_SCRIPT_CACHE,$SERVER_TIMEZONE_CACHE,$HAS_SET_ERROR_HANDLER,$DYING_BADLY,$XSS_DETECT,$SITE_INFO,$IN_MINIKERNEL_VERSION,$EXITING,$FILE_BASE,$CACHE_TEMPLATES,$BASE_URL_HTTP_CACHE,$BASE_URL_HTTPS_CACHE,$WORDS_TO_FILTER_CACHE,$FIELD_RESTRICTIONS,$VALID_ENCODING,$CONVERTED_ENCODING,$MICRO_BOOTUP,$MICRO_AJAX_BOOTUP,$QUERY_LOG,$_CREATED_FILES,$CURRENT_SHARE_USER,$FIND_SCRIPT_CACHE,$WHAT_IS_RUNNING_CACHE,$DEV_MODE,$SEMI_DEV_MODE,$IS_VIRTUALISED_REQUEST,$FILE_ARRAY,$DIR_ARRAY,$JAVASCRIPTS_DEFAULT,$JAVASCRIPTS,$KNOWN_AJAX;

	if (ini_get('output_buffering')=='1') @ob_end_clean(); // Reset to have no output buffering by default (we'll use it internally, taking complete control)

	// Fixup some inconsistencies in parameterisation on different PHP platforms
	if (array_key_exists('HTTP_X_REWRITE_URL',$_SERVER))
	{
		foreach ($_GET as $key=>$val)
		{
			if ($key[0]=='?')
			{
				unset($_GET[$key]);
				$_GET[substr($key,1)]=$val;
			}
		}
		$_SERVER['REQUEST_URI']=$_SERVER['HTTP_X_REWRITE_URL'];
	} elseif ((!array_key_exists('REQUEST_URI',$_SERVER)) && (!array_key_exists('REQUEST_URI',$_ENV)))
	{
		$_SERVER['REQUEST_URI']=$_SERVER['PHP_SELF'];
		$first=true;
		foreach ($_GET as $key=>$val)
		{
			$_SERVER['REQUEST_URI'].=$first?'?':'&';
			$_SERVER['REQUEST_URI'].=urlencode($key).'='.urlencode($val);
			$first=false;
		}
	}
	if ((array_key_exists('SCRIPT_FILENAME',$_SERVER)) && (!array_key_exists('PHP_SELF',$_SERVER))) $_SERVER['PHP_SELF']=$_SERVER['SCRIPT_FILENAME'];
	elseif ((array_key_exists('SCRIPT_NAME',$_SERVER)) && (defined('HIPHOP_PHP'))) $_SERVER['PHP_SELF']=$_SERVER['SCRIPT_NAME'];

	// Don't want the browser caching PHP output, explicitly say this
	@header('Expires: Mon, 20 Dec 1998 01:00:00 GMT');
	@header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
	//@header('Cache-Control: no-cache, must-revalidate'); // DISABLED AS MAKES IE RELOAD ON 'BACK' AND LOSE FORM CONTENTS
	@header('Pragma: no-cache'); // for proxies, and also IE

	// Closed site message
	if ((strpos($_SERVER['PHP_SELF'],'upgrader.php')===false) && ((!isset($SITE_INFO['no_extra_closed_file'])) || ($SITE_INFO['no_extra_closed_file']!='1')))
	{
		if ((is_file('closed.html')) || (@is_file('../closed.html')))
		{
			if ((@strpos($_SERVER['SERVER_SOFTWARE'],'IIS')===false)) header('HTTP/1.0 503 Service Temporarily Unavailable');
			header('Location: '.get_base_url().'closed.html');
			exit();
		}
	}

	// Initialise some globals
	$JAVASCRIPTS_DEFAULT=array('javascript'=>1,'javascript_transitions'=>1);
	if ($GLOBALS['CURRENT_SHARE_USER']!==NULL) $JAVASCRIPTS_DEFAULT['javascript_ajax']=1; // AJAX needed by shared installs
	$RUNNING_SCRIPT_CACHE=array();
	$BROWSER_DECACHEING_CACHE=NULL;
	$CHARSET_CACHE=NULL;
	$TEMP_CHARSET_CACHE=NULL;
	$CURRENTLY_HTTPS_CACHE=NULL;
	$FIND_SCRIPT_CACHE=array();
	$WHAT_IS_RUNNING_CACHE=current_script();
	$WORDS_TO_FILTER_CACHE=NULL;
	$FIELD_RESTRICTIONS=NULL;
	$VALID_ENCODING=false;
	$CONVERTED_ENCODING=false;
	$KNOWN_AJAX=false;
	/** Whether we are loading up in micro-bootup mode (reduced amount of loading for quicker simple responses).
	 * @global BINARY $MICRO_BOOTUP
	 */
	if (!isset($MICRO_BOOTUP)) $MICRO_BOOTUP=0;
	/** Whether we are loading up in micro-ajax-bootup mode (reduced amount of loading for quicker simple AJAX responses).
	 * @global BINARY $MICRO_AJAX_BOOTUP
	 */
	if (!isset($MICRO_AJAX_BOOTUP)) $MICRO_AJAX_BOOTUP=0;
	/** Whether we know input text is in UTF8 because it came from an AJAX call (which is always UTF).
	 * @global boolean $KNOWN_UTF8
	 */
	if (!isset($KNOWN_UTF8)) $KNOWN_UTF8=false;
	$CACHE_TEMPLATES=true;
	$IS_VIRTUALISED_REQUEST=false;
	/** On the quick installer, this presents manifest information about files that exist in the virtual filesystem.
	 * @global ?array $FILE_ARRAY
	 */
	$FILE_ARRAY=NULL;
	/** On the quick installer, this presents manifest information about directories that exist in the virtual filesystem.
	 * @global ?array $DIR_ARRAY
	 */
	$DIR_ARRAY=NULL;

	// Keep check of our bootstrapping
	$BOOTSTRAPPING=1;
	$CHECKING_SAFEMODE=false;

	// Initialise timezones
	$SERVER_TIMEZONE_CACHE=@date_default_timezone_get();
	date_default_timezone_set('UTC');

	// Initialise some error handling
	error_reporting(E_ALL);
	$HAS_SET_ERROR_HANDLER=false;
	$DYING_BADLY=false; // If ocPortal is bailing out uncontrollably, setting this will make sure the error hander does not try and suppress

	// Dev mode stuff
	/** Whether the ocProducts version of PHP is running, and hence whether XSS-detection is enabled, and hence whether we may need to carry through additional meta-data to make sure it operates correctly. Stored in a global for quick check (good performance).
	 * @global boolean $XSS_DETECT
	 */
	$XSS_DETECT=function_exists('ocp_mark_as_escaped');
	/** Whether ocPortal is running in development mode
	 * @global boolean $DEV_MODE
	 */
	$DEV_MODE=(((!array_key_exists('dev_mode',$SITE_INFO) || ($SITE_INFO['dev_mode']=='1')) && ((is_dir(get_file_base().'/.svn')) || (is_dir(get_file_base().'/.git')) || (function_exists('ocp_mark_as_escaped')))) && ((!array_key_exists('keep_no_dev_mode',$_GET) || ($_GET['keep_no_dev_mode']=='0'))));
	/** Whether ocPortal is running in a more limited development mode, which may make things a bit slower and more verbose, but won't run such severe standard enforcement tricks
	 * @global boolean $SEMI_DEV_MODE
	 */
	$SEMI_DEV_MODE=(((!array_key_exists('dev_mode',$SITE_INFO) || ($SITE_INFO['dev_mode']=='1')) && ((is_dir(get_file_base().'/.svn')) || (is_dir(get_file_base().'/.git')) || (function_exists('ocp_mark_as_escaped')))));
	if (function_exists('set_time_limit')) @set_time_limit(60);
	if ($DEV_MODE)
	{
		if (function_exists('set_time_limit')) @set_time_limit(10);
		@ini_set('ocproducts.type_strictness','1');
		@ini_set('ocproducts.xss_detect','1');
	}
	if ($DEV_MODE)
	{
		require_code('developer_tools');
	}

	// Load most basic config
	/** Whether ocPortal is currently running from the 'minikernel' used during installation
	 * @global BINARY $IN_MINIKERNEL_VERSION
	 */
	$IN_MINIKERNEL_VERSION=0;
	$EXITING=0;
	if ((array_key_exists('use_ocf',$_GET)) && (running_script('upgrader')))
	{
		$SITE_INFO['forum_type']='ocf';
		$SITE_INFO['ocf_table_prefix']=$SITE_INFO['table_prefix'];
	}

	// The URL to our install (no trailing /)
	$BASE_URL_HTTP_CACHE=NULL;
	$BASE_URL_HTTPS_CACHE=NULL;

	require_code_no_override('version');
	if (($MICRO_BOOTUP==0) && ($MICRO_AJAX_BOOTUP==0))
	{
		// Marker that ocPortal running
		@header('X-Powered-By: ocPortal '.ocp_version_pretty().' (PHP '.phpversion().')');

		// Get ready for query logging if requested
		$QUERY_LOG=false;
		if ((isset($_REQUEST['special_page_type'])) && ($_REQUEST['special_page_type']=='query'))
		{
			$QUERY_LOG=true;
		}
	}

	// Most critical things
	require_code('global3'); // A lot of support code is present in this
	srand(make_seed());
	mt_srand(make_seed());
	if (($MICRO_BOOTUP==0) && ($MICRO_AJAX_BOOTUP==0)) // Fast cacheing for bots
	{
		if ((running_script('index')) && (count($_POST)==0))
		{
			$bot_type=get_bot_type();
			if (($bot_type!==NULL) && (isset($SITE_INFO['fast_spider_cache'])) && ($SITE_INFO['fast_spider_cache']!='') && ($SITE_INFO['fast_spider_cache']!='0'))
			{
				fast_spider_cache(true);
			}
		}
	}
	require_code('caches');
	require_code('database'); // There's nothing without the database
	require_code('config'); // Config is needed for much active stuff
	require_code('global4');
	if (ip_banned(get_ip_address())) critical_error('BANNED');
	if ((running_script('messages')) && (get_param('action','new')=='new') && (get_param_integer('routine_refresh',0)==0)) // Architecturally unsound chat message precheck (for extra efficiency)
	{
		require_code('chat_poller');
		chat_poller();
	}
	if ($MICRO_BOOTUP==0)
	{
		load_user_stuff();
	}

	// For any kind of niceness we need these. The order is chosen for complex dependency reasons - don't mess with it
	if ($MICRO_AJAX_BOOTUP==0)
	{
		require_code('themes'); // Output needs to know about themes
		require_code('templates'); // So that we can do error templates
		require_code('tempcode'); // Output is done with tempcode
		if ($MICRO_BOOTUP==0)
		{
			require_code('comcode'); // Much output goes through comcode
		}
	}
	require_code('zones'); // Zone is needed because zones are where all ocPortal pages reside

	if ((get_option('collapse_user_zones',true)==='1') && ($RELATIVE_PATH=='site'))
	{
		get_base_url();/*force calculation first*/
		$RELATIVE_PATH='';
	}
	require_code('users'); // Users are important due to permissions
	if (($MICRO_BOOTUP==0) && ($MICRO_AJAX_BOOTUP==0)) // Fast cacheing for Guests
	{
		if ((running_script('index')) && (count($_POST)==0))
		{
			if ((isset($SITE_INFO['any_guest_cached_too'])) && ($SITE_INFO['any_guest_cached_too']=='1') && (is_guest(NULL,true)))
			{
				fast_spider_cache(false);
			}
		}
	}
	$CACHE_TEMPLATES=((get_option('is_on_template_cache')=='1') || (get_param_integer('keep_cache',0)==1) || (get_param_integer('cache',0)==1)) && (get_param_integer('keep_cache',NULL)!==0) && (get_param_integer('cache',NULL)!==0);
	if ($MICRO_AJAX_BOOTUP==0)
	{
		require_code('temporal'); // Date/time functions
		require_code('files'); // Contains fix_permissions, needed for 'lang'
		require_code('lang'); // So that we can do language stuff (e.g. errors)
		convert_data_encodings();
		if ($MICRO_BOOTUP==0)
		{
			require_code('permissions'); // So we can check access
		}
	}

	// At this point we can display errors nicely
	$GLOBALS['SUPRESS_ERROR_DEATH']=false;
	set_error_handler('ocportal_error_handler');
	if (function_exists('error_get_last')) register_shutdown_function('catch_fatal_errors');
	$HAS_SET_ERROR_HANDLER=true;

	// Initialise members
	if ($MICRO_BOOTUP==0)
	{
		if (method_exists($GLOBALS['FORUM_DRIVER'],'forum_layer_initialise')) $GLOBALS['FORUM_DRIVER']->forum_layer_initialise();
	}

	// More things to initialise
	if ($MICRO_BOOTUP==0)
	{
		if (($IN_MINIKERNEL_VERSION!=1) && ($MICRO_AJAX_BOOTUP==0))
		{
			has_cookies(); // Will determine at early point whether we have cookie support
			get_num_users_site(); // Will kill site if there are too many users
		}
	}
	require_code('urls'); // URL building is crucial

	// Register Internationalisation settings
	@header('Content-type: text/html; charset='.get_charset());
	if ((function_exists('setlocale')) && ($MICRO_AJAX_BOOTUP==0))
	{
		$locales=explode(',',do_lang('locale'));
		setlocale(LC_ALL,$locales[0]);
		@setlocale(LC_ALL,$locales);
		unset($locales);
	}

	// Check RBL's
	$spam_check_level=get_option('spam_check_level',true);
	if ($spam_check_level==='EVERYTHING')
	{
		if (get_option('spam_block_lists')!='')
		{
			require_code('antispam');
			check_rbls(true);
		}
	}

	if (($MICRO_AJAX_BOOTUP==0) && ($MICRO_BOOTUP==0))
	{
		// Before anything gets outputted
		handle_logins();

		require_code('site'); // This powers the site (top level page generation)

		// Are we installed?
		get_option('site_name');
	}

	// Our logging (change false to true for temporarily changing it so staff get logging)
	if (get_option('log_php_errors')=='1')
	{
		@ini_set('log_errors','1');
		if (addon_installed('errorlog'))
			@ini_set('error_log',get_custom_file_base().'/data_custom/errorlog.php');
	}
	if (($MICRO_BOOTUP==0) && ($MICRO_AJAX_BOOTUP==0) && ((get_option('display_php_errors')=='1') || (running_script('upgrader')) || (has_privilege(get_member(),'see_php_errors'))))
	{
		@ini_set('display_errors','1');
	} elseif (!$DEV_MODE) @ini_set('display_errors','0');

	// G-zip?
	@ini_set('zlib.output_compression',(get_option('gzip_output')=='1')?'On':'Off');

	// Check installer not left behind
	if (($MICRO_AJAX_BOOTUP==0) && ($MICRO_BOOTUP==0) && ((!isset($SITE_INFO['no_installer_checks'])) || ($SITE_INFO['no_installer_checks']!='1')))
	{
		if ((is_file(get_file_base().'/install.php')) && (!is_file(get_file_base().'/install_ok')) && (running_script('index')))
			warn_exit(do_lang_tempcode('MUST_DELETE_INSTALLER'));
	}

	if (($MICRO_AJAX_BOOTUP==0) && ($MICRO_BOOTUP==0))
	{
		// Clear cacheing if needed
		$changed_base_url=!array_key_exists('base_url',$SITE_INFO) && get_long_value('last_base_url')!==get_base_url(false);
		if ((running_script('index')) && ((is_browser_decacheing()) || ($changed_base_url)))
		{
			require_code('view_modes');
			erase_tempcode_cache();
			erase_cached_templates(!$changed_base_url);
			erase_cached_language();
			persistent_cache_empty();
			if ($changed_base_url)
			{
				require_lang('zones');
				require_code('zones3');
				erase_comcode_page_cache();
				set_long_value('last_base_url',get_base_url(false));
			}
		}

		// Load requirements for admins
		if (has_zone_access(get_member(),'adminzone'))
		{
			$JAVASCRIPTS_DEFAULT['javascript_staff']=1;
			$JAVASCRIPTS_DEFAULT['javascript_ajax']=1;
			if (addon_installed('occle')) $JAVASCRIPTS_DEFAULT['javascript_button_occle']=1;
		}
		if ((addon_installed('realtime_rain')) && (get_option('bottom_show_realtime_rain_button',true)==='1')) $JAVASCRIPTS_DEFAULT['javascript_button_realtime_rain']=1;
		$JAVASCRIPTS+=$JAVASCRIPTS_DEFAULT;
	}
	/*ocp_memory_profile('startup');	If debugging with inbuilt profiler
	$func=get_defined_functions();
	print_r($func['user']);*/

	// Okay, we've loaded everything critical. Don't need to tell ocPortal to be paranoid now.
	$BOOTSTRAPPING=0;

	if (($SEMI_DEV_MODE) && ($MICRO_AJAX_BOOTUP==0)) // Lots of code that only runs if you're a programmer. It tries to make sure coding standards are met.
	{
		if ($SEMI_DEV_MODE)
		{
			/*if ((mt_rand(0,2)==1) && ($DEV_MODE) && (running_script('index')))	We know this works now, so let's stop messing up our development speed
			{
				require_code('view_modes');
				erase_cached_templates(true); // Stop anything trying to read a template cache item (E.g. CSS, JS) that might not exist!
			}*/

			if ((strpos(ocp_srv('HTTP_REFERER'),ocp_srv('HTTP_HOST'))!==false) && (strpos(ocp_srv('HTTP_REFERER'),'keep_devtest')!==false) && (!running_script('attachment')) && (!running_script('upgrader')) && (strpos(ocp_srv('HTTP_REFERER'),'login')===false) && (is_null(get_param('keep_devtest',NULL))))
			{
				$_GET['keep_devtest']='1';
				fatal_exit('URL not constructed properly: development mode in use but keep_devtest was not specified. This indicates that links have been made without build_url (in PHP) or keep_stub (in Javascript). Whilst not fatal this time, failure to use these functions can cause problems when your site goes live. See the ocPortal codebook for more details.');
			} else $_GET['keep_devtest']='1';
		}

		if (isset($_CREATED_FILES)) // Comes from ocProducts custom PHP version
		{
			/**
			 * Run after-tests for debug mode, to make sure coding standards are met.
			 */
			function dev_mode_aftertests()
			{
				global $_CREATED_FILES,$_MODIFIED_FILES;

				// Use the info from ocProduct's custom PHP version to make sure that all files that were created/modified got synched as they should have been.
				foreach ($_CREATED_FILES as $file)
				{
					if ((substr($file,0,strlen(get_file_base()))==get_file_base()) && (substr($file,-4)!='.tmp') && (substr($file,-4)!='.log') && (basename($file)!='permissioncheckslog.php'))
						@exit(escape_html('File not permission-synched: '.$file));
				}
				foreach ($_MODIFIED_FILES as $file)
				{
					if ((strpos($file,'_cache')===false) && (substr($file,0,strlen(get_file_base()))==get_file_base()) && (substr($file,-4)!='.tmp') && (substr($file,-4)!='.log') && (basename($file)!='permissioncheckslog.php'))
						@exit(escape_html('File not change-synched: '.$file));
				}

				global $TITLE_CALLED,$SCREEN_TEMPLATE_CALLED,$EXITING;
				if ((is_null($SCREEN_TEMPLATE_CALLED)) && ($EXITING==0) && (strpos(ocp_srv('PHP_SELF'),'index.php')!==false)) @exit(escape_html('No screen template called.'));
				if ((!$TITLE_CALLED) && ((is_null($SCREEN_TEMPLATE_CALLED)) || ($SCREEN_TEMPLATE_CALLED!='')) && ($EXITING==0) && (strpos(ocp_srv('PHP_SELF'),'index.php')!==false)) @exit(escape_html('No title used on screen.'));
			}

			register_shutdown_function('dev_mode_aftertests');
		}

		if ((ocp_srv('SCRIPT_FILENAME')!='') && ($DEV_MODE) && (strpos(ocp_srv('SCRIPT_FILENAME'),'data_custom')===false))
		{
			if (@strlen(file_get_contents(ocp_srv('SCRIPT_FILENAME')))>4500)
			{
				fatal_exit('Entry scripts (front controllers) should not be shoved full of code.');
			}
		}
	}

	// FirePHP console support, only for administrators
	if ((get_param_integer('keep_firephp',0)==1) && (($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())) || ($GLOBALS['IS_ACTUALLY_ADMIN'])))
	{
		require_code('firephp');
	}

	// Reduce down memory limit / raise if requested
	$default_memory_limit=get_value('memory_limit');
	if ((is_null($default_memory_limit)) || ($default_memory_limit=='') || ($default_memory_limit=='0') || ($default_memory_limit=='-1'))
		$default_memory_limit='64M';
	@ini_set('memory_limit',$default_memory_limit);
	if ((isset($GLOBALS['FORUM_DRIVER'])) && ($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())))
	{
		if (get_param_integer('keep_avoid_memory_limit',0)==1)
		{
			disable_php_memory_limit();
		}
		$memory_test=get_param_integer('keep_memory_limit_test',0);
		if (($memory_test!=0) && ($memory_test<=32))
		{
			@ini_set('memory_limit',strval($memory_test).'M');
		}
	}

	// Initialise site-wide IM
	if ((get_option('sitewide_im',true)==='1') && (running_script('index')) /* i.e. not running script */ && (get_param('type','misc',true)!='room'))
	{
		require_code('chat');
		enter_chat_lobby();
	}

	// Detect and deal with spammers that triggered the spam blackhole
	if (get_option('spam_blackhole_detection')=='1')
	{
		if (post_param(md5(get_site_name().': antispam'),'')!='')
		{
			log_hack_attack_and_exit('LAME_SPAM_HACK','<blackhole>'.post_param(md5(get_site_name().': antispam'),'').'</blackhole>');
		}
	}

	// Startup hooks
	if (!running_script('upgrader'))
	{
		$startup_hooks=find_all_hooks('systems','startup');
		foreach (array_keys($startup_hooks) as $hook)
		{
			require_code('hooks/systems/startup/'.filter_naughty_harsh($hook));
			$ob=object_factory('Hook_startup_'.filter_naughty_harsh($hook),true);
			if ($ob===NULL) continue;
			$ob->run($MICRO_BOOTUP,$MICRO_AJAX_BOOTUP,0);
		}
		if (($CURRENT_SHARE_USER!==NULL) && (float_to_raw_string(ocp_version_number())!=get_value('version')))
		{
			require_code('upgrade');
			clear_caches_2();
			version_specific();
			upgrade_modules();
			ocf_upgrade();
		}
	}
}

/**
 * Get ready for outputting an AJAX response.
 */
function prepare_for_known_ajax_response()
{
	header('Cache-Control: no-cache, must-revalidate'); // HTTP/1.1
	header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); // Date in the past

	convert_data_encodings(true);

	global $KNOWN_AJAX;
	$KNOWN_AJAX=true;
}

/**
 * Find if we can use the fast spider cache.
 *
 * @return boolean			Whether we can
 */
function can_fast_spider_cache()
{
	if (isset($_GET['keep_session'])) return false;
	if (isset($_GET['redirect'])) return false;
	if (isset($_GET['zone'])) return false;
	if (isset($_GET['date'])) return false;
	$url_easy=get_self_url_easy();
	if (strpos($url_easy,'sort=')!==false) return false;
	if (strpos($url_easy,'start=')!==false) return false;
	if (strpos($url_easy,'max=')!==false) return false;
	return true;
}

/**
 * If possible dump the user to 100% static caching.
 *
 * @param  boolean			Whether to cache as a bot
 */
function fast_spider_cache($bot=true)
{
	global $SITE_INFO;

	require_code('urls');

	if (!can_fast_spider_cache()) return;

	$fast_cache_path=get_custom_file_base().'/persistent_cache/'.md5(serialize(get_self_url_easy()));
	if (!$bot) $fast_cache_path.='__non-bot';
	if (!array_key_exists('js_on',$_COOKIE)) $fast_cache_path.='__no-js';
	if (is_mobile()) $fast_cache_path.='_mobile';
	$fast_cache_path.='.gcd';
	if (is_file($fast_cache_path))
	{
		$expires=60*60*intval($SITE_INFO['fast_spider_cache']);
		$mtime=filemtime($fast_cache_path);
		if ($mtime>time()-$expires)
		{
			if ($bot) // Only bots can do this, as they won't try to login and end up reaching a previously cached page
			{
				header("Pragma: public");
				header("Cache-Control: maxage=".strval($expires));
				header('Expires: '.gmdate('D, d M Y H:i:s',time()+$expires).' GMT');
				header('Last-Modified: '.gmdate('D, d M Y H:i:s',$mtime).' GMT');

				$since=ocp_srv('HTTP_IF_MODIFIED_SINCE');
				if ($since!='')
				{
					if (strtotime($since)<$mtime)
					{
						header('HTTP/1.0 304 Not Modified');
						exit();
					}
				}
			}

			if (function_exists('gzencode'))
			{
				ini_set('zlib.output_compression','Off');
				header('Content-Encoding: gzip');
			}

			$contents=file_get_contents($fast_cache_path);
			if (function_exists('ocp_mark_as_escaped')) ocp_mark_as_escaped($contents);
			exit($contents);
		} else
		{
			@unlink($fast_cache_path);
			sync_file($fast_cache_path);
		}
	}
}

/**
 * Disable the PHP memory limit. Do not use this carelessly, use it if a screen is a bit fat or in an importer, don't use it assuming memory is infinite.
 */
function disable_php_memory_limit()
{
	$shl=@ini_get('suhosin.memory_limit');
	if (($shl===false) || ($shl=='') || ($shl=='0'))
	{
		@ini_set('memory_limit','64M');
		@ini_set('memory_limit','-1');
	} else
	{
		@ini_set('memory_limit',$shl);
	}
}

/**
 * Get the character set to use. We try and be clever to allow AJAX scripts to avoid loading up language
 *
 * @return string			The character set
 */
function get_charset()
{
	global $CHARSET_CACHE,$XSS_DETECT;
	if (isset($CHARSET_CACHE)) return $CHARSET_CACHE;

	global $SITE_INFO;
	if ((isset($SITE_INFO['charset'])) && ($SITE_INFO['charset']!='')) // An optimisation, if you want to put it in here
	{
		$CHARSET_CACHE=$SITE_INFO['charset'];
		if ($XSS_DETECT) ocp_mark_as_escaped($CHARSET_CACHE);
		return $CHARSET_CACHE;
	}

	global $LANG_LOADED_LANG;
	if ((function_exists('do_lang')) && (function_exists('user_lang')) && (isset($LANG_LOADED_LANG[user_lang()]['critical_error'])) && (!in_safe_mode()))
	{
		$attempt=do_lang('charset',NULL,NULL,NULL,NULL,false);
		if ($attempt!==NULL)
		{
			$CHARSET_CACHE=$attempt;
			return $attempt;
		}
	}

	global $TEMP_CHARSET_CACHE;
	if (isset($TEMP_CHARSET_CACHE)) return $TEMP_CHARSET_CACHE;

	global $SITE_INFO;
	$lang=array_key_exists('default_lang',$SITE_INFO)?$SITE_INFO['default_lang']:'EN';
	$path=get_file_base().'/lang_custom/'.$lang.'/global.ini';
	if (!is_file($path)) $path=get_file_base().'/lang/'.$lang.'/global.ini';
	if (!is_file($path))
	{
		$path=get_file_base().'/lang_custom/'.$lang.'/global.po';
		if (is_file($path))
		{
			$TEMP_CHARSET_CACHE='utf-8';
			return $TEMP_CHARSET_CACHE;
		}
	}
	if (!is_file($path))
	{
		$path=get_file_base().'/lang_custom/'.$lang.'/global-'.strtolower($lang).'.po';
		if (is_file($path))
		{
			$TEMP_CHARSET_CACHE='utf-8';
			return $TEMP_CHARSET_CACHE;
		}
	}
	if (!is_file($path)) $path=get_file_base().'/lang/EN/global.ini';
	$file=fopen($path,'rt');
	$contents=str_replace(chr(13),chr(10),fread($file,3000));
	fclose($file);
	$matches=array();
	if (preg_match('#\[strings\].*charset=([\w\-]+)\n#s',$contents,$matches)!=0)
	{
		$TEMP_CHARSET_CACHE=$matches[1];
		if ($XSS_DETECT) ocp_mark_as_escaped($TEMP_CHARSET_CACHE);
		return $TEMP_CHARSET_CACHE;
	}
	$TEMP_CHARSET_CACHE='utf-8';
	return $TEMP_CHARSET_CACHE;
}

/**
 * Load stuff that allows user code to work.
 */
function load_user_stuff()
{
	if ((!array_key_exists('FORUM_DRIVER',$GLOBALS)) || ($GLOBALS['FORUM_DRIVER']===NULL)) // Second clause is for Quercus, as it pre-NULLs referenced variables
	{
		global $SITE_INFO,$FORUM_DRIVER,$SITE_DB,$FORUM_DB;

		require_code('forum_stub');

		if (!array_key_exists('forum_type',$SITE_INFO)) $SITE_INFO['forum_type']='ocf';
		require_code('forum/'.$SITE_INFO['forum_type']);	 // So we can at least get user details
		/** The active forum driver, through which member and forum interfacing should be done (apart from code that is explicitly only written as part of OCF)
		 * @global object $FORUM_DRIVER
		 */
		$FORUM_DRIVER=object_factory('forum_driver_'.filter_naughty_harsh($SITE_INFO['forum_type']));
		if (($SITE_INFO['forum_type']=='ocf') && (get_db_forums()==get_db_site()) && ($FORUM_DRIVER->get_drivered_table_prefix()==get_table_prefix()) && (!$GLOBALS['DEV_MODE'])) // NB: In debug mode needs separating so we can properly test our boundaries
		{
			$FORUM_DRIVER->connection=&$SITE_DB;
		}
		elseif ($SITE_INFO['forum_type']!='none')
		{
			$FORUM_DRIVER->connection=new database_driver(get_db_forums(),get_db_forums_host(),get_db_forums_user(),get_db_forums_password(),$FORUM_DRIVER->get_drivered_table_prefix());
		}
		$FORUM_DRIVER->MEMBER_ROWS_CACHED=array();
		/** The connection to the active forum database.
		 * @global object $FORUM_DB
		 */
		$FORUM_DB=mixed();
		$GLOBALS['FORUM_DB']=&$FORUM_DRIVER->connection; // Done like this to workaround that PHP can't put a reference in a global'd variable
	}
}

/**
 * ocPortal error catcher for fatal versions. This is hooked in only on PHP5.2 as error_get_last() only works on these versions.
 */
function catch_fatal_errors()
{
	if (!function_exists('error_get_last')) return;

	$error=error_get_last();

	if (!is_null($error))
	{
		if (!array_key_exists('message',$error)) return; // Needed for HipHop PHP
		if (substr($error['message'],0,26)=='Maximum execution time of ')
		{
			if (function_exists('i_force_refresh'))
			{
				i_force_refresh();
			}
		}
		//$tmp=$GLOBALS;unset($tmp['GLOBALS']);@var_dump($tmp);@exit();
		//@var_dump(get_defined_functions()); exit(); // Useful for debugging memory problems, finding unneeded stuff that is loaded
		switch($error['type'])
		{
			case E_ERROR:
			case E_CORE_ERROR:
			case E_COMPILE_ERROR:
			case E_USER_ERROR:
				$GLOBALS['SUPRESS_ERROR_DEATH']=false; // We can't recover as we've lost our execution track. Force a nice death rather than trying to display a recoverable error.
				$GLOBALS['DYING_BADLY']=true; // Does not actually work unfortunately. @'d calls never get here at all.
				ocportal_error_handler($error['type'],$error['message'],$error['file'],$error['line']);
		}
	}
}

/**
 * ocPortal error handler (hooked into PHP error system).
 *
 * @param  integer		The error code-number
 * @param  PATH			The error message
 * @param  string			The file the error occurred in
 * @param  integer		The line the error occurred on
 * @return boolean		Always false
 */
function ocportal_error_handler($errno,$errstr,$errfile,$errline)
{
	if ((error_reporting()==0) && (!$GLOBALS['DYING_BADLY'])) return false; // This actually tells if @ was used oddly enough. You wouldn't figure from the PHP docs.

	if ((error_reporting() & $errno) || ($GLOBALS['DYING_BADLY']))
	{
		// Strip down path for security
		if (substr(str_replace(DIRECTORY_SEPARATOR,'/',$errfile),0,strlen(get_file_base().'/'))==str_replace(DIRECTORY_SEPARATOR,'/',get_file_base().'/'))
			$errfile=substr($errfile,strlen(get_file_base().'/'));

		// Work out the error type
		if (!defined('E_RECOVERABLE_ERROR')) define('E_RECOVERABLE_ERROR',4096);
		switch ($errno)
		{
			case E_RECOVERABLE_ERROR: // constant not defined in all php versions but we defined it
			case E_USER_ERROR:
			case E_PARSE:
			case E_CORE_ERROR:
			case E_COMPILE_ERROR:
			case E_ERROR:
				$type='error';
				break;
			case -123: // Hacked in for the memtrack extension, which was buggy
			case E_CORE_WARNING:
			case E_COMPILE_WARNING:
			case E_USER_WARNING:
			case E_WARNING:
				$type='warning';
				break;
			//case E_STRICT: (constant not defined in all php versions)
			//case E_DEPRECATED: (constant not defined in all php versions)
			//case E_USER_DEPRECATED: (constant not defined in all php versions)
			case E_USER_NOTICE:
			case E_NOTICE:
				$type='notice';
				break;
			default: // We don't know the error type so it's probably best to continue (could be a problem with something getting deprecated)
				return false;
		}

		$GLOBALS['DYING_BADLY']=false; // So error suppress works again
		if (strpos($errstr,'Allowed memory')!==false)
		{
			global $REQUIRED_CODE;
			if (!array_key_exists('failure',$REQUIRED_CODE))
			{
				critical_error('EMERGENCY',$errstr.escape_html(' ['.$errfile.' at '.strval($errline).']'));
			}
		}
		require_code('failure');
		_ocportal_error_handler($type,$errno,$errstr,$errfile,$errline);
	}

	return false;
}

/*function ocp_memory_profile($id)
{
	if (!function_exists('memory_get_usage')) return;
	echo memory_get_usage().'  ('.$id.')<br />';
}
function ocp_memory_profile_2($id,&$struct)
{
	if (!function_exists('memory_get_usage')) return;
	@ob_end_clean();
	echo memory_get_usage().'  ('.$id.')'.(is_null($struct)?'':(' ['.strlen(var_export($struct,true)).']')).'<br />';
}*/

/**
 * Find whether the browser session is set to be doing a hard cache-empty refresh.
 *
 * @return boolean		Whether the browser session is set to be doing a hard cache-empty refresh
 */
function is_browser_decacheing()
{
	global $BROWSER_DECACHEING_CACHE;
	if ($BROWSER_DECACHEING_CACHE!==NULL) return $BROWSER_DECACHEING_CACHE;

	if (is_null(get_value('ran_once')))
	{
		set_value('ran_once','1');
		return true;
	}
	$header_method=(array_key_exists('HTTP_CACHE_CONTROL',$_SERVER)) && ($_SERVER['HTTP_CACHE_CONTROL']=='no-cache') && (ocp_srv('REQUEST_METHOD')!='POST') && ((!function_exists('browser_matches')) || (!browser_matches('opera')));
	$BROWSER_DECACHEING_CACHE=(($header_method) && ((array_key_exists('FORUM_DRIVER',$GLOBALS)) && (has_actual_page_access(get_member(),'admin_cleanup')) || ($GLOBALS['IS_ACTUALLY_ADMIN'])));
	return $BROWSER_DECACHEING_CACHE;
}

/**
 * Find out what script is running.
 *
 * @return ID_TEXT			The script running (usually 'index')
 */
function current_script()
{
	// Strip down current URL so we can do a simple compare
	global $WHAT_IS_RUNNING_CACHE;
	if ($WHAT_IS_RUNNING_CACHE===NULL)
	{
		$stripped_current_url=preg_replace('#^.*/#','',function_exists('ocp_srv')?ocp_srv('PHP_SELF'):$_SERVER['PHP_SELF']);
		$WHAT_IS_RUNNING_CACHE=substr($stripped_current_url,0,strpos($stripped_current_url,'.'));
	}
	return $WHAT_IS_RUNNING_CACHE;
}

/**
 * Find whether a certain script is being run to get here.
 *
 * @param  string				Script filename (canonically we want NO .php file type suffix)
 * @return boolean			Whether the script is running
 */
function running_script($is_this_running)
{
	// First check cache
	global $RUNNING_SCRIPT_CACHE;
	if (isset($RUNNING_SCRIPT_CACHE[$is_this_running.'.php'])) return $RUNNING_SCRIPT_CACHE[$is_this_running.'.php'];
	if (isset($RUNNING_SCRIPT_CACHE[$is_this_running])) return $RUNNING_SCRIPT_CACHE[$is_this_running];

	// Do the stem compare
	$answer=(current_script()==$is_this_running);

	// Cache and return result
	$RUNNING_SCRIPT_CACHE[$is_this_running]=$answer;
	return $answer;
}

/**
 * This is a intended to output an informational exit at the same time as terminating execution
 *
 * @param  mixed			The error message (string or tempcode)
 */
function inform_exit($text)
{
	require_code('failure'); // It's in failure.php although this isn't REALLY failure. Still it's an exceptional event so we can't justify loading the code as global.
	_generic_exit($text,'INFORM_SCREEN');
}

/**
 * This is a less-revealing alternative to fatal_exit, that is used for user-errors/common-corruption-scenarios
 *
 * @param  mixed			The error message (string or tempcode)
 */
function warn_exit($text)
{
	require_code('failure');
	suggest_fatalistic();
	_generic_exit($text,'WARN_SCREEN');
	if (running_script('cron_bridge'))
		relay_error_notification(is_object($text)?$text->evaluate():escape_html($text),false,'error_occurred_cron');
}

/**
 * Give the user an option to see a stack trace by adding in a link, but only if they have permission
 */
function suggest_fatalistic()
{
	if ((may_see_stack_dumps()) && (get_param_integer('keep_fatalistic',0)==0) && (running_script('index')))
	{
		if (count($_POST)==0)
		{
			$stack_trace_url=build_url(array('page'=>'_SELF','keep_fatalistic'=>1),'_SELF',NULL,true);
			$st=do_lang_tempcode('WARN_TO_STACK_TRACE',escape_html($stack_trace_url->evaluate()));
		} elseif (count($_FILES)==0)
		{
			$stack_trace_url=build_url(array('page'=>'_SELF','keep_fatalistic'=>1),'_SELF',NULL,true);
			$p=build_keep_post_fields();
			$st=do_lang_tempcode('WARN_TO_STACK_TRACE_2',escape_html($stack_trace_url->evaluate()),$p->evaluate());
		} else
		{
			$stack_trace_url=build_url(array('page'=>'','keep_fatalistic'=>1),'');
			$st=do_lang_tempcode('WARN_TO_STACK_TRACE_3',escape_html($stack_trace_url->evaluate()));
		}
		require_code('site');
		attach_message($st,'inform');
	}
}

/**
 * Do a fatal exit, echo the header (if possible) and an error message, followed by a debugging back-trace.
 * It also adds an entry to the error log, for reference.
 *
 * @param  mixed				The error message (string or tempcode)
 */
function fatal_exit($text)
{
	require_code('failure');
	_fatal_exit($text);
}

/**
 * Log a hackattack, then displays an error message. It also attempts to send an e-mail to the staff alerting them of the hackattack.
 *
 * @param  ID_TEXT		The reason for the hack attack. This has to be a language string codename
 * @param  SHORT_TEXT	A parameter for the hack attack language string (this should be based on a unique ID, preferably)
 * @param  SHORT_TEXT	A more illustrative parameter, which may be anything (e.g. a title)
 */
function log_hack_attack_and_exit($reason,$reason_param_a='',$reason_param_b='')
{
	require_code('failure');
	_log_hack_attack_and_exit($reason,$reason_param_a,$reason_param_b);
}

/**
 * Use the url_title_cache table (a bit of a hack but saved changed the DB structure) to see if a check-op was performed has been performed within the last 30 days.
 *
 * @param  ID_TEXT		Special check code (often a URL but does not need to be).
 * @return boolean		Whether the check has happened recently.
*/
function handle_has_checked_recently($id_code)
{
	$last_check_test=$GLOBALS['SITE_DB']->query_select_value_if_there('url_title_cache','t_title',array('t_url'=>'!'.$id_code));
	if ((is_null($last_check_test)) || (substr($last_check_test,0,1)!='!') || (intval(substr($last_check_test,1))+60*60*24*30<time())) // only re-checks every 30 days
	{
		// Show when it was last tested
		$GLOBALS['SITE_DB']->query_delete('url_title_cache',array('t_url'=>'!'.$id_code),'',1); // To make sure it can insert below
		$GLOBALS['SITE_DB']->query_insert('url_title_cache',array('t_title'=>'!'.strval(time()),'t_url'=>'!'.$id_code),false,true); // To stop weird race-like conditions

		return false;
	}

	return true;
}

/**
 * A custom random number seed generator. It returns a random number seed.
 *
 * @return integer		A random seed
 */
function make_seed()
{
	list($usec,$sec)=explode(' ', microtime(false));
	$u=produce_salt();
	return intval(floatval($sec)*floatval($usec))+ord(substr($u,0,1))+(ord(substr($u,1,2))<<8);
}

/**
 * Get the major version of your installation.
 *
 * @return integer		The major version number of your installation
 */
function ocp_version()
{
	return intval(ocp_version_number());
}

/**
 * Get the full string version of ocPortal that you are running, in 'pretty' format.
 * This is (and must be kept) equivalent to get_version_pretty__from_dotted(get_version_dotted())
 *
 * @return string			The string saying the full ocPortal version number
 */
function ocp_version_pretty()
{
	$minor=ocp_version_minor();
	return preg_replace('#\.(alpha|beta|RC)#',' ${1}',strval(ocp_version()).(($minor=='')?'':'.'.$minor));
}

/**
 * Get the domain the website is installed on (preferably, without any www). The domain is used for e-mail defaults amongst other things.
 *
 * @return string			The domain of the website
 */
function get_domain()
{
	global $SITE_INFO;
	$ret=array_key_exists('domain',$SITE_INFO)?$SITE_INFO['domain']:'';
	if ($ret=='')
	{
		if ((!array_key_exists('base_url',$SITE_INFO)) || ($SITE_INFO['base_url']=='')) return array_key_exists('HTTP_HOST',$_SERVER)?preg_replace('#^www\.#','',$_SERVER['HTTP_HOST']):'localhost'; // Can't be ocp_srv due to bootstrap order
		$matches=array();
		preg_match('#://([^/\#]+)#',$SITE_INFO['base_url'],$matches);
		$ret=preg_replace('#^www\.#','',$matches[1]);
	}
	return $ret;
}

/**
 * Get the type of forums installed.
 *
 * @return string			The type of forum installed
 */
function get_forum_type()
{
	global $SITE_INFO;
	if (!isset($SITE_INFO['forum_type'])) $SITE_INFO['forum_type']='ocf';
	return $SITE_INFO['forum_type'];
}

/**
 * Get the installed forum base URL.
 *
 * @param  boolean		Whether to get the base directory of the forum. Unless running OCF, this makes no difference - if possibly running OCF, you need to think about this parameter: are you trying to reach the MSN-central-site or just a link to the forums?
 * @return URLPATH		The installed forum base URL
 */
function get_forum_base_url($forum_base=false)
{
	global $SITE_INFO;

	if ((!array_key_exists('board_prefix',$SITE_INFO)) || ($SITE_INFO['board_prefix']=='')) $SITE_INFO['board_prefix']=get_base_url();
	$forum_type=get_forum_type();
	if ($forum_type=='none') return '';
	$needs_forum_strip=(substr($SITE_INFO['board_prefix'],-6)=='/forum') && (substr(get_base_url(),-6)!='/forum');
	if (($forum_type=='ocf') && (!$forum_base) && ($needs_forum_strip)) return substr($SITE_INFO['board_prefix'],0,strlen($SITE_INFO['board_prefix'])-6);
	if (($forum_type=='ocf') && ($forum_base) && ($needs_forum_strip)) return $SITE_INFO['board_prefix'].'/forum';
	return $SITE_INFO['board_prefix'];
}

/**
 * Get the ocPortal cookie path.
 *
 * @return ?string		The ocPortal cookie path (NULL: no special path, global)
 */
function get_cookie_path()
{
	global $SITE_INFO;
	$ret=array_key_exists('cookie_path',$SITE_INFO)?$SITE_INFO['cookie_path']:'/';
	return ($ret=='')?NULL:$ret;
}

/**
 * Get the ocPortal cookie domain.
 *
 * @return ?string		The ocPortal cookie domain (NULL: current domain)
 */
function get_cookie_domain()
{
	global $SITE_INFO;
	$ret=array_key_exists('cookie_domain',$SITE_INFO)?$SITE_INFO['cookie_domain']:NULL;
	return ($ret=='')?NULL:$ret;
}

/**
 * Get the number of days to store our cookies.
 *
 * @return integer		The number of days to store our cookies
 */
function get_cookie_days()
{
	global $SITE_INFO;
	return array_key_exists('cookie_domain',$SITE_INFO)?intval($SITE_INFO['cookie_days']):120;
}

/**
 * Get the site name.
 *
 * @return string			The name of the site
 */
function get_site_name()
{
	return get_option('site_name');
}

/**
 * Find whether we are running in safe mode.
 *
 * @return boolean		Whether we are in safe mode
 */
function in_safe_mode()
{
	global $SITE_INFO;
	if ((isset($SITE_INFO['safe_mode'])) && ($SITE_INFO['safe_mode']=='1')) return true; // Useful for testing HPHP support

	global $CHECKING_SAFEMODE;
	if ($CHECKING_SAFEMODE) return false; // Stops infinite loops (e.g. Check safe mode > Check access > Check usergroups > Check implicit usergroup hooks > Check whether to look at custom implicit usergroup hooks [i.e. if not in safe mode])
	$CHECKING_SAFEMODE=true;
	$ret=((get_param_integer('keep_safe_mode',0)==1) && ((isset($GLOBALS['IS_ACTUALLY_ADMIN']) && ($GLOBALS['IS_ACTUALLY_ADMIN'])) || (!array_key_exists('FORUM_DRIVER',$GLOBALS)) || ($GLOBALS['FORUM_DRIVER']===NULL) || (!function_exists('get_member')) || ($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member()))));
	$CHECKING_SAFEMODE=false;
	return $ret;
}

/**
 * Find the URL to a certain external handler script (ocPortal allows these to be moved around between zones, to suit site .htaccess requirements).
 *
 * @param  string			The codename of the needed script
 * @param  boolean		Whether to append keep variables
 * @param  integer		Code representing what base URL type to use (0=guess, 1=http, 2=https)
 * @set 0 1 2
 * @return URLPATH		The URL to the script
 */
function find_script($name,$append_keep=false,$base_url_code=0)
{
	$append='';
	if ($append_keep)
	{
		$keep=symbol_tempcode('KEEP',array('1'));
		$append.=$keep->evaluate();
	}

	global $FIND_SCRIPT_CACHE;
	if ($FIND_SCRIPT_CACHE===array())
	{
		if (function_exists('persistent_cache_get')) $FIND_SCRIPT_CACHE=persistent_cache_get('SCRIPT_PLACES');
		if ($FIND_SCRIPT_CACHE===NULL) $FIND_SCRIPT_CACHE=array();
	}
	if (isset($FIND_SCRIPT_CACHE[$name][$append_keep][$base_url_code])) return $FIND_SCRIPT_CACHE[$name][$append_keep][$base_url_code].$append;

	$zones=array(get_zone_name());
	if (!in_safe_mode())
	{
		$zones[]='data_custom';
	}
	$zones[]='data';
	$zones=array_merge($zones,find_all_zones());
	foreach ($zones as $zone)
	{
		if ($zone!='site') // If not found, we assume in here
		{
			if (is_file(get_file_base().'/'.$zone.'/'.$name.'.php'))
			{
				$ret=get_base_url().'/'.$zone.(($zone!='')?'/':'').$name.'.php';
				$FIND_SCRIPT_CACHE[$name][$append_keep][$base_url_code]=$ret;
				if (function_exists('persistent_cache_set')) persistent_cache_set('SCRIPT_PLACES',$FIND_SCRIPT_CACHE,true);
				return $ret.$append;
			}
		}
	}
	$ret=get_base_url(($base_url_code==0)?NULL:($base_url_code==2)).'/site/'.$name.'.php';
	$FIND_SCRIPT_CACHE[$name][$append_keep][$base_url_code]=$ret;
	if (function_exists('persistent_cache_set')) persistent_cache_set('SCRIPT_PLACES',$FIND_SCRIPT_CACHE,true);
	return $ret.$append;
}

/**
 * Get the base url (the minimum fully qualified URL to our installation).
 *
 * @param  ?boolean		Whether to get the HTTPS base URL (NULL: do so only if the current page uses the HTTPS base URL)
 * @param  ?ID_TEXT		The zone the link is for (NULL: root zone)
 * @return URLPATH		The base-url
 */
function get_base_url($https=NULL,$zone_for=NULL)
{
	if ($https===NULL) // If we don't know, we go by what the current page is
	{
		global $CURRENTLY_HTTPS_CACHE;
		$https=$CURRENTLY_HTTPS_CACHE;
		if ($https===NULL)
		{
			if ((get_option('enable_https',true)=='0') || (!running_script('index')))
			{
				$https=tacit_https();
			} else
			{
				$https=((tacit_https()) || (function_exists('is_page_https')) && (function_exists('get_zone_name')) && (is_page_https(get_zone_name(),get_page_name())));
			}
			$CURRENTLY_HTTPS_CACHE=$https;
		}
	}

	global $BASE_URL_HTTP_CACHE,$BASE_URL_HTTPS_CACHE,$VIRTUALISED_ZONES_CACHE;

	if ($VIRTUALISED_ZONES_CACHE===NULL)
	{
		require_code('zones');
		get_zone_name();
	}

	if (($BASE_URL_HTTP_CACHE!==NULL) && (!$https) && ((!$VIRTUALISED_ZONES_CACHE) || ($zone_for===NULL))) return $BASE_URL_HTTP_CACHE.(($zone_for=='')?'':('/'.$zone_for));
	if (($BASE_URL_HTTPS_CACHE!==NULL) && ($https) && ((!$VIRTUALISED_ZONES_CACHE) || ($zone_for===NULL))) return $BASE_URL_HTTPS_CACHE.(($zone_for=='')?'':('/'.$zone_for));

	global $SITE_INFO;
	if ((!isset($SITE_INFO)) || (!array_key_exists('base_url',$SITE_INFO)) || ($SITE_INFO['base_url']=='')) // Try and autodetect the base URL if it's not configured
	{
		$domain=ocp_srv('HTTP_HOST');
		$colon_pos=strpos($domain,':');
		if ($colon_pos!==false) $domain=substr($domain,0,$colon_pos);
		$port=ocp_srv('SERVER_PORT');
		if (($port=='') || ($port=='80') || ($port=='443')) $port=''; else $port=':'.$port;
			$SITE_INFO['base_url']='http://'.$domain.$port.str_replace('%2F','/',rawurlencode(preg_replace('#/'.preg_quote($GLOBALS['RELATIVE_PATH'],'#').'$#','',str_replace('\\','/',dirname(ocp_srv('PHP_SELF'))))));
	}

	// Lookup
	$base_url=$SITE_INFO['base_url'];
	global $CURRENT_SHARE_USER;
	if ($CURRENT_SHARE_USER!==NULL)
	{
		$base_url=preg_replace('#^http://([\w]+\.)?'.preg_quote($SITE_INFO['custom_share_domain'],'#').'#','http://'.ocp_srv('HTTP_HOST'),$base_url);
	}
	$found_mapping=false;
	if ($VIRTUALISED_ZONES_CACHE) // Special searching if we are doing a complex zone scheme
	{
		$zone_doing=($zone_for===NULL)?'':str_replace('/','',$zone_for);

		if (array_key_exists('ZONE_MAPPING_'.$zone_doing,$SITE_INFO))
		{
			$domain=$SITE_INFO['ZONE_MAPPING_'.$zone_doing][0];
			$path=$SITE_INFO['ZONE_MAPPING_'.$zone_doing][1];
			$base_url='http://'.$domain;
			if ($path!='') $base_url.='/'.$path;
			$found_mapping=true;
		}
	}

	// Work out correct variant
	if ($https)
	{
		$base_url='https://'.preg_replace('#^\w*://#','',$base_url);
		if ((!$VIRTUALISED_ZONES_CACHE) || ($zone_for===NULL)) $BASE_URL_HTTPS_CACHE=$base_url;
	} elseif ((!$VIRTUALISED_ZONES_CACHE) || ($zone_for===NULL)) $BASE_URL_HTTP_CACHE=$base_url;

	if (!$found_mapping) // Scope inside the correct zone
	{
		$base_url.=(($zone_for=='')?'':('/'.$zone_for));
	}

	// Done
	return $base_url;
}

/**
 * Get the base url (the minimum fully qualified URL to our personal data installation). For a shared install only, this is different to the base-url.
 *
 * @param  ?boolean		Whether to get the HTTPS base URL (NULL: do so only if the current page uses the HTTPS base URL)
 * @return URLPATH		The base-url
 */
function get_custom_base_url($https=NULL)
{
	global $SITE_INFO;
	if (!isset($SITE_INFO['custom_base_url_stub'])) return get_base_url($https);

	// Note that HTTPS is not supported for shared installs
	$u=current_share_user();
	if ($u===NULL) return get_base_url($https);
	return $SITE_INFO['custom_base_url_stub'].'/'.$u;
}

/**
 * Function to get a base URL for an OCF relative-URL. The situation is complex as it needs to take into account OCF multi-site-network's, locally defined theme images, and shared-installs (myocp style).
 *
 * @param  URLPATH		Short base URL we need to probe
 * @return URLPATH		The appropriate base-url
 */
function get_complex_base_url($at)
{
	return ((get_forum_base_url()!=get_base_url())?get_forum_base_url():((substr($at,0,22)=='themes/default/images/')?get_base_url():get_custom_base_url()));
}

/**
 * Get a value (either POST [u]or[/u] GET), or the default if neither can be found.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined (NULL: allow missing parameter) (false: give error on missing parameter)
 * @return ?string		The parameter value (NULL: missing)
 */
function either_param($name,$default=false)
{
	$a=__param(array_merge($_POST,$_GET),$name,$default,false,NULL);
	if ($a===NULL) return NULL;

	if ($a!==$default) // Check input field security
	{
		require_code('input_filter');
		check_input_field($name,$a);
	}
	return function_exists('ocp_url_decode_post_process')?ocp_url_decode_post_process($a):$a;
}

/**
 * Get the value of the specified POST key, if it is found, or the default otherwise.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined (NULL: allow missing parameter) (false: give error on missing parameter)
 * @param  boolean		Whether we are cleaning for HTML rather than Comcode/plain-text
 * @param  boolean		Whether to convert WYSIWYG contents to Comcode automatically
 * @return ?string		The parameter value (NULL: missing)
 */
function post_param($name,$default=false,$html=false,$conv_from_wysiwyg=true)
{
	$a=__param($_POST,$name,$default,false,true);

	if ($a===NULL) return NULL;
	if ((trim($a)=='') && ($default!=='') && (array_key_exists('require__'.$name,$_POST)) && ($_POST['require__'.$name]!='0'))
	{
		require_code('failure');
		improperly_filled_in_post($name);
	}

	if (($a!='') && (addon_installed('wordfilter')))
	{
		if ($name!='password')
		{
			require_code('word_filter');
			$a=check_word_filter($a,$name);
		}
	}
	if ($a!==NULL) $a=unixify_line_format($a,NULL,$html);

	if ((isset($_POST[$name.'__is_wysiwyg'])) && ($_POST[$name.'__is_wysiwyg']=='1') && ($conv_from_wysiwyg))
	{
		if (trim($a)=='')
		{
			$a='';
		} else
		{
			require_code('comcode_from_html');
			$a=trim(semihtml_to_comcode($a));
		}
	} else
	{
		if ((substr($a,0,10)=='[semihtml]') && (substr(trim($a),-11)=='[/semihtml]'))
		{
			$_a=trim($a);
			$_a=substr($_a,10,strlen($_a)-11-10);
			if (strpos($_a,'[semihtml')===false)
			{
				require_code('comcode_from_html');
				$a=trim(semihtml_to_comcode($_a));
			}
		}
	}

	return function_exists('ocp_url_decode_post_process')?ocp_url_decode_post_process($a):$a;
}

/**
 * Get the value of the specified GET key, if it is found, or the default otherwise.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined (NULL: allow missing parameter) (false: give error on missing parameter)
 * @param  boolean		Whether to skip the security check
 * @return ?string		The parameter value (NULL: missing)
 */
function get_param($name,$default=false,$no_security=false)
{
	$a=__param($_GET,$name,$default);
	if (($a=='') && (isset($_GET['require__'.$name])) && ($default!==$a) && ($_GET['require__'.$name]!='0'))
	{
		// We didn't give some required input
		set_http_status_code('400');
		warn_exit(do_lang_tempcode('IMPROPERLY_FILLED_IN'));
	}
	if ($a===$default) return $a;

	if (strpos($a,':')!==false)
		$a=function_exists('ocp_url_decode_post_process')?ocp_url_decode_post_process($a):$a;

	// Security check
	$is_url=($name=='from') || ($name=='preview_url') || ($name=='redirect') || ($name=='redirect_passon') || ($name=='url');
	if (($name!='s_message') && (!$is_url) && (!$no_security))
	{
		if (((isset($a[100])) && (strpos(substr($a,10),'::slash::slash:')===false) && (strpos(substr($a,10),'://')===false) && (strpos(substr($a,10),'::slash::slash:')===false)) || (preg_match('#\n|\000|<|(".*[=<>])|\.\./|^\s*((((j\s*a\s*v\s*a\s*)|(v\s*b\s*))?s\s*c\s*r\s*i\s*p\s*t)|(d\s*a\s*t\s*a\s*))\s*:#mi',$a)!=0))
		{
			log_hack_attack_and_exit('DODGY_GET_HACK',$name,$a);
		}
	} else
	{
		if ($is_url)
		{
			if (preg_match('#\n|\000|<|(".*[=<>])|^\s*((((j\s*a\s*v\s*a\s*)|(v\s*b\s*))?s\s*c\s*r\s*i\s*p\s*t)|(d\s*a\s*t\s*a\s*))\s*:#mi',$a)!=0)
			{
				log_hack_attack_and_exit('DODGY_GET_HACK',$name,$a);
			}

			$bu=get_base_url();
			if ((looks_like_url($a)) && (substr($a,0,strlen($bu))!=$bu) && (substr($a,0,strlen(get_forum_base_url()))!=get_forum_base_url())) // Don't allow external redirections
			{
				$a=get_base_url();
			}
		}
	}

	if ($a===NULL) return NULL;
	return $a;
}

/**
 * Helper function to load up a GET/POST parameter.
 *
 * @param  array			The array we're extracting parameters from
 * @param  string			The name of the parameter
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined (NULL: allow missing parameter) (false: give error on missing parameter)
 * @param  boolean		Whether the parameter has to be an integer
 * @param  ?boolean		Whether the parameter is a POST parameter (NULL: undetermined)
 * @return string			The value of the parameter
 */
function __param($array,$name,$default,$integer=false,$posted=false)
{
	if ((!isset($array[$name])) || (($integer) && ($array[$name]=='')))
	{
		if ($default!==false) return $default;

		require_code('failure');
		improperly_filled_in($name,$posted,$array);
	}

	$val=$array[$name];
	if (is_array($val)) $val=implode(',',$val);
	if (get_magic_quotes_gpc()) $val=stripslashes($val);

	if (($posted) && ($GLOBALS['BOOTSTRAPPING']==0) && ($GLOBALS['MICRO_AJAX_BOOTUP']==0)) // Check against fields.xml
	{
		require_code('input_filter');
		return check_posted_field($name,$val);
	}

	return $val;
}

/**
 * Do a wildcard match by converting to a regular expression.
 *
 * @param  string			The haystack
 * @param  string			The needle (a wildcard expression)
 * @param  boolean		Whether full-coverance is required
 * @return boolean		Whether we have a match
 */
function simulated_wildcard_match($context,$word,$full_cover=false)
{
	$rexp=str_replace('%','.*',str_replace('_','.',str_replace('\\?','.',str_replace('\\*','.*',preg_quote($word)))));
	if ($full_cover) $rexp='^'.$rexp.'$';

	return preg_match('#'.str_replace('#','\#',$rexp).'#i',$context)!=0;
}

/**
 * This function is the integeric partner of either_param, as it returns the value as an integer.
 * You should always use integer specified versions when inputting integers, for the added security that type validation allows. If the value is of the wrong type, it indicates a hack attempt and will be logged.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined or the empty string (NULL: allow missing parameter) (false: give error on missing parameter)
 * @return ?integer		The parameter value (NULL: not set, and NULL given as default)
 */
function either_param_integer($name,$default=false)
{
	$ret=__param(array_merge($_POST,$_GET),$name,($default===false)?$default:(($default===NULL)?'':strval($default)),true,NULL); // $_REQUEST contains cookies too, so can't use
	if (($default===NULL) && ($ret==='')) return NULL;
	$ret=trim($ret);
	if (!is_numeric($ret))
	{
		require_code('failure');
		$ret=_param_invalid($name,$ret,true);
	}
	$reti=intval($ret);
	if (($reti>2147483647) || ($reti<-2147483648))
	{
		require_code('failure');
		_param_invalid($name,NULL,true);
	}
	return $reti;
}

/**
 * This function is the integeric partner of post_param, as it returns the value as an integer.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined or the empty string (NULL: allow missing parameter) (false: give error on missing parameter)
 * @return ?integer		The parameter value (NULL: not set, and NULL given as default)
 */
function post_param_integer($name,$default=false)
{
	$ret=__param($_POST,$name,($default===false)?$default:(($default===NULL)?'':strval($default)),true,true);
	if (($default===NULL) && ($ret==='')) return NULL;
	$ret=trim($ret);
	if (!is_numeric($ret))
	{
		require_code('failure');
		$ret=_param_invalid($name,$ret,true);
	}
	if ($ret=='0') return 0;
	if ($ret=='1') return 1;
	$reti=intval($ret);
	$retf=floatval($reti);
	if (($retf>2147483647.0) || ($retf<-2147483648.0))
	{
		if ($name!='captcha')
		{
			require_code('failure');
			_param_invalid($name,NULL,true);
		}
	}
	return $reti;
}

/**
 * This function is the integeric partner of get_param, as it returns the value as an integer.
 *
 * @param  ID_TEXT		The name of the parameter to get
 * @param  ?mixed			The default value to give the parameter if the parameter value is not defined or the empty string (NULL: allow missing parameter) (false: give error on missing parameter)
 * @param  boolean		If a string is given, use the default parameter rather than giving an error (only use this if you are suffering from a parameter conflict situation between different parts of ocPortal)
 * @return ?integer		The parameter value (NULL: not set, and NULL given as default)
 */
function get_param_integer($name,$default=false,$not_string_ok=false)
{
	$m_default=($default===false)?false:(isset($default)?(($default==0)?'0':strval($default)):'');
	$ret=__param($_GET,$name,$m_default,true); // do not set $ret to mixed(), breaks bootstrapping
	if ((!isset($default)) && ($ret==='')) return NULL;
	$ret=trim($ret);
	if (!is_numeric($ret))
	{
		if (substr($ret,-1)=='/') $ret=substr($ret,0,strlen($ret)-1);
		if (!is_numeric($ret)) // Bizarre situation (bug in IIS?)
		{
			$matches=array();
			if (preg_match('#^(\d+)\#[\w]*$#',$ret,$matches)!=0)
			{
				$ret=$matches[1];
			} else
			{
				if ($not_string_ok) return $default;
				require_code('failure');
				$ret=_param_invalid($name,$ret,false);
			}
		}
	}
	if ($ret=='0') return 0;
	if ($ret=='1') return 1;
	$reti=intval($ret);
	$retf=floatval($reti);
	if (($retf>2147483647.0) || ($retf<-2147483648.0))
	{
		require_code('failure');
		_param_invalid($name,NULL,false);
	}
	return $reti;
}

/**
 * Make sure that lines are seperated by chr(10), with no chr(13)'s there at all. For Mac data, this will be a flip scenario. For Linux data this will be a null operation. For windows data this will be change from chr(13).chr(10) to just chr(10). For a realistic scenario, data could have originated on all kinds of platforms, with some editors converting, some situations being inter-platform, and general confusion. Don't make blind assumptions - use this function to clean data, then write clean code that only considers chr(10)'s.
 *
 * @param  string			The data to clean
 * @param  ?ID_TEXT		The character set it should be in. We don't do any real conversions using this, only make sure that common problems with fed ISO-8859-1 data are resolved (NULL: output character set)
 * @param  boolean		Whether we are cleaning for HTML rather than Comcode/plain-text
 * @param  boolean		Whether the file is loaded from disk (less conversion needed)
 * @return string			The cleaned data
 */
function unixify_line_format($in,$desired_charset=NULL,$html=false,$from_disk=false)
{
	if ($in=='') return $in;

	if ($desired_charset===NULL) $desired_charset=get_charset();

	$in=str_replace(array(chr(13).chr(10),'&#8298;',chr(13)),array(chr(10),'',chr(10)),$in); // &#8298; is very odd- seems to come from open office copy & paste
	return $in;
}

/**
 * Force a Javascript file to be cached (ordinarily we can rely on this to be automated by require_javascript/javascript_tempcode).
 *
 * @param  string			The javascript file required
 * @param  ?ID_TEXT		The name of the theme (NULL: current theme)
 * @param  ?boolean		Whether to minify (NULL: read from environment)
 * @return string			The path to the javascript file in the cache (blank: no file)
 */
function javascript_enforce($j,$theme=NULL,$minify=NULL)
{
	if (get_param_integer('keep_textonly',0)==1) return '';

	if ($minify===NULL)
		$minify=(get_param_integer('keep_no_minify',0)==0);

	global $SITE_INFO;

	// Make sure the Javascript exists
	if ($theme===NULL)
		$theme=filter_naughty($GLOBALS['FORUM_DRIVER']->get_theme());
	$dir=get_custom_file_base().'/themes/'.$theme.'/templates_cached/'.filter_naughty(user_lang());
	if ((!isset($SITE_INFO['no_disk_sanity_checks'])) || ($SITE_INFO['no_disk_sanity_checks']!='1'))
	{
		if (!is_dir($dir))
		{
			if (@mkdir($dir,0777)===false)
			{
				warn_exit(do_lang_tempcode('WRITE_ERROR_DIRECTORY_REPAIR',escape_html($dir)));
			}
			fix_permissions($dir,0777);
			sync_file($dir);
		}
	}
	$js_cache_path=$dir.'/'.filter_naughty_harsh($j);
	if (!$minify) $js_cache_path.='_non_minified';
	if ((get_option('enable_https',true)=='1') && function_exists('is_page_https') && function_exists('get_zone_name') && ((tacit_https()) || is_page_https(get_zone_name(),get_page_name())))
		$js_cache_path.='_ssl';
	if (is_mobile()) $js_cache_path.='_mobile';
	$js_cache_path.='.js';

	global $CACHE_TEMPLATES;
	$support_smart_decaching=(!isset($SITE_INFO['disable_smart_decaching'])) || ($SITE_INFO['disable_smart_decaching']!='1');
	$is_cached=($CACHE_TEMPLATES || !running_script('index')/*must cache for non-index to stop getting blanked out in depended sub-script output generation and hence causing concurrency issues*/) && (@(filesize($js_cache_path)!=0)) && (!is_browser_decacheing()) && (!in_safe_mode());

	if (($support_smart_decaching) || (!$is_cached))
	{
		$found=find_template_place(strtoupper($j),'',$theme,'.tpl','templates');
		if ($found===NULL) return '';
		$theme=$found[0];
		$fullpath=get_custom_file_base().'/themes/'.$theme.$found[1].strtoupper($j).'.tpl';
		if (!is_file($fullpath))
			$fullpath=get_file_base().'/themes/'.$theme.$found[1].strtoupper($j).'.tpl';
		$globals_custom=str_replace('default/templates/JAVASCRIPT.tpl',filter_naughty($GLOBALS['FORUM_DRIVER']->get_theme()).'/templates_custom/JAVASCRIPT_CUSTOM_GLOBALS.tpl',$fullpath);
	}

	if ((($support_smart_decaching) && ((@(filemtime($js_cache_path)<filemtime($fullpath)) && (@filemtime($fullpath)<time())) || (@filemtime(get_file_base().'/_config.php')>@filemtime($js_cache_path)) || ((is_file($globals_custom)) && (@filemtime($globals_custom)>@filemtime($js_cache_path))))) || (!$is_cached))
	{
		require_code('css_and_js');
		js_compile($j,$js_cache_path,$minify);
	}

	if (filesize($js_cache_path)==0) return '';

	return $js_cache_path;
}

/**
 * Get tempcode to tie in (to the HTML, in <head>) all the Javascript files that have been required.
 *
 * @param  ?string		Position to get Javascript for (NULL: all positions)
 * @set NULL header footer
 * @return tempcode		The tempcode to tie in the Javascript files
 */
function javascript_tempcode($position=NULL)
{
	global $JAVASCRIPTS,$JAVASCRIPT;
	$js=new ocp_tempcode();

	$minify=(get_param_integer('keep_no_minify',0)==0);
	$https=((get_option('enable_https',true)=='1') && function_exists('is_page_https') && function_exists('get_zone_name') && ((tacit_https()) || is_page_https(get_zone_name(),get_page_name())));
	$mobile=is_mobile();

	$grouping_codename=_handle_web_resource_merging('.js',$JAVASCRIPTS,$minify,$https,$mobile);

	// Fix order, so our main Javascript runs first
	$arr_backup=$JAVASCRIPTS;
	$JAVASCRIPTS=array();
	$JAVASCRIPTS[($grouping_codename=='')?'javascript':$grouping_codename]=($grouping_codename=='')?1:0;
	$JAVASCRIPTS+=$arr_backup;

	$bottom_ones=array('javascript_staff'=>1,'javascript_button_occle'=>1,'javascript_button_realtime_rain'=>1,'javascript_fractional_edit'=>1,'javascript_transitions'=>1); // These are all framework ones that add niceities
	foreach ($JAVASCRIPTS as $j=>$do_enforce)
	{
		if ($position!==NULL)
		{
			$bottom=(isset($bottom_ones[$j]));
			if (($position=='header') && ($bottom)) continue;
			if (($position=='footer') && (!$bottom)) continue;
		}

		$temp=($do_enforce==1)?javascript_enforce($j):'';
		if (($temp!='') || ($do_enforce==0))
		{
			if (!$minify) $j.='_non_minified';
			if ($https) $j.='_ssl';
			if ($mobile) $j.='_mobile';

			global $SITE_INFO;
			$support_smart_decaching=(!isset($SITE_INFO['disable_smart_decaching'])) || ($SITE_INFO['disable_smart_decaching']!='1');
			$sup=($support_smart_decaching && $temp!='')?strval(filemtime($temp)):NULL; // Tweaks caching so that upgrades work without needing emptying browser cache; only runs if smart decaching is on because otherwise we won't have the mtime and don't want to introduce an extra filesystem hit

			$js->attach(do_template('JAVASCRIPT_NEED',array('_GUID'=>'b5886d9dfc4d528b7e1b0cd6f0eb1670','CODE'=>$j,'SUP'=>$sup)));
		}
	}
	if (!is_null($JAVASCRIPT)) $js->attach($JAVASCRIPT);
	return $js;
}

/**
 * Make sure that the given javascript file is loaded up.
 *
 * @sets_output_state
 *
 * @param  ID_TEXT		The javascript file required
 */
function require_javascript($javascript)
{
	if ($javascript=='javascript_forums_embed') // Has to be first
	{
		$GLOBALS['JAVASCRIPTS']=array_merge(array('javascript_forums_embed'=>1),$GLOBALS['JAVASCRIPTS']);
	} else
	{
		$GLOBALS['JAVASCRIPTS'][$javascript]=1;
	}
}

/**
 * Force a CSS file to be cached.
 *
 * @param  string			The CSS file required
 * @param  ?ID_TEXT		The name of the theme (NULL: current theme)
 * @param  ?boolean		Whether to minify (NULL: read from environment)
 * @return string			The path to the CSS file in the cache (blank: no file)
 */
function css_enforce($c,$theme=NULL,$minify=NULL)
{
	$text_only=(get_param_integer('keep_textonly',0)==1);
	if ($text_only) $c.='_textonly';

	if ($minify===NULL)
		$minify=(get_param_integer('keep_no_minify',0)==0);

	global $SITE_INFO;

	// Make sure the CSS file exists
	if ($theme===NULL)
		$theme=@method_exists($GLOBALS['FORUM_DRIVER'],'get_theme')?$GLOBALS['FORUM_DRIVER']->get_theme():'default';
	$active_theme=$theme;
	$dir=get_custom_file_base().'/themes/'.$theme.'/templates_cached/'.filter_naughty(user_lang());
	if ((!isset($SITE_INFO['no_disk_sanity_checks'])) || ($SITE_INFO['no_disk_sanity_checks']!='1'))
	{
		if (!is_dir($dir))
		{
			if (@mkdir($dir,0777)===false)
			{
				warn_exit(do_lang_tempcode('WRITE_ERROR_DIRECTORY_REPAIR',escape_html($dir)));
			}
			fix_permissions($dir,0777);
			sync_file($dir);
		}
	}
	$css_cache_path=$dir.'/'.filter_naughty_harsh($c);
	if (!$minify) $css_cache_path.='_non_minified';
	if ((get_option('enable_https',true)=='1') && function_exists('is_page_https') && function_exists('get_zone_name') && ((tacit_https()) || is_page_https(get_zone_name(),get_page_name())))
		$css_cache_path.='_ssl';
	if (is_mobile()) $css_cache_path.='_mobile';
	$css_cache_path.='.css';

	global $CACHE_TEMPLATES;
	$support_smart_decaching=(!isset($SITE_INFO['disable_smart_decaching'])) || ($SITE_INFO['disable_smart_decaching']!='1');
	$is_cached=($CACHE_TEMPLATES || !running_script('index')/*must cache for non-index to stop getting blanked out in depended sub-script output generation and hence causing concurrency issues*/) && (@(filesize($css_cache_path)!=0)) && (!is_browser_decacheing()) && (!in_safe_mode());

	if (($support_smart_decaching) || (!$is_cached) || ($text_only))
	{
		$found=find_template_place($c,'',$theme,'.css','css');
		if ($found===NULL) return '';
		$theme=$found[0];
		$fullpath=get_custom_file_base().'/themes/'.$theme.$found[1].$c.'.css';
		if (!is_file($fullpath))
			$fullpath=get_file_base().'/themes/'.$theme.$found[1].$c.'.css';
		if (($text_only) && (!is_file($fullpath))) return '';
	}

	if (((!$is_cached) || (($support_smart_decaching) && (@(filemtime($css_cache_path)<filemtime($fullpath)) && (@filemtime($fullpath)<time())))))
	{
		require_code('css_and_js');
		css_compile($active_theme,$theme,$c,$fullpath,$css_cache_path,$minify);
	}

	if (filesize($css_cache_path)==0) return '';

	return $css_cache_path;
}

/**
 * Get tempcode to tie in (to the HTML, in <head>) all the CSS files that have been required.
 *
 * @param  boolean		Force inline CSS
 * @param  boolean		Only do global CSS
 * @param  ?string		HTML context for which we filter (minimise) any CSS we spit out as inline (NULL: none)
 * @param  ?ID_TEXT		The name of the theme (NULL: current theme)
 * @return tempcode		The tempcode to tie in the CSS files
 */
function css_tempcode($inline=false,$only_global=false,$context=NULL,$theme=NULL)
{
	global $CSSS;

	$seed='';
	if (has_privilege(get_member(),'view_profiling_modes'))
	{
		$seed=get_param('keep_theme_seed','');
	}

	$text_only=(get_param_integer('keep_textonly',0)==1);
	$minify=(get_param_integer('keep_no_minify',0)==0);
	$https=((get_option('enable_https',true)=='1') && function_exists('is_page_https') && function_exists('get_zone_name') && ((tacit_https()) || is_page_https(get_zone_name(),get_page_name())));
	$mobile=is_mobile();

	if (!$only_global)
		_handle_web_resource_merging('.css',$CSSS,$minify,$https,$mobile);

	$css=new ocp_tempcode();
	$css_need_inline=new ocp_tempcode();
	$css_to_do=$only_global?array('global'=>1,'no_cache'=>1):$CSSS;

	foreach ($css_to_do as $c=>$do_enforce)
	{
		if ($seed!='')
		{
			$keep=symbol_tempcode('KEEP');
			$css->attach(do_template('CSS_NEED_FULL',array('_GUID'=>'f2d7f0303a08b9aa9e92f8b0208ee9a7','URL'=>find_script('themewizard').'?type=css&show='.urlencode($c).'.css'.$keep->evaluate()),user_lang(),false,NULL,'.tpl','templates',$theme));
		}
		elseif (($c=='no_cache') || ($inline))
		{
			if (!$text_only)
			{
				$_css=do_template($c,NULL,user_lang(),false,NULL,'.css','css',$theme);
				$__css=$_css->evaluate();
				if ($context!==NULL)
				{
					$__css=filter_css($__css,$context);
				} else
				{
					$__css=str_replace('} ','}'.chr(10),preg_replace('#\s+#',' ',$__css));
				}

				if (trim($__css)!='')
					$css_need_inline->attach(do_template('CSS_NEED_INLINE',array('_GUID'=>'f5b225e080c633ffa033ec5af5aec866','CSS'=>$__css),user_lang(),false,NULL,'.tpl','templates',$theme));
			}
		} else
		{
			$temp=($do_enforce==1)?css_enforce($c,$theme):'';
			if (!$minify) $c.='_non_minified';
			if ($https) $c.='_ssl';
			if ($mobile) $c.='_mobile';
			if (($temp!='') || ($do_enforce==0))
			{
				global $SITE_INFO;
				$support_smart_decaching=(!isset($SITE_INFO['disable_smart_decaching'])) || ($SITE_INFO['disable_smart_decaching']!='1');
				$sup=($support_smart_decaching && $temp!='')?strval(filemtime($temp)):NULL; // Tweaks caching so that upgrades work without needing emptying browser cache; only runs if smart decaching is on because otherwise we won't have the mtime and don't want to introduce an extra filesystem hit

				$css->attach(do_template('CSS_NEED',array('_GUID'=>'ed35fac857214000f69a1551cd483096','CODE'=>$c,'SUP'=>$sup),user_lang(),false,NULL,'.tpl','templates',$theme));
			}
		}
	}
	$css_need_inline->attach($css);
	return $css_need_inline;
}

/**
 * Make sure that the given CSS file is loaded up.
 *
 * @sets_output_state
 *
 * @param  ID_TEXT		The CSS file required
 */
function require_css($css)
{
	$GLOBALS['CSSS'][$css]=1;
}

/**
 * Handle web resource merging optimisation, for merging groups of CSS/Javascript files that are used across the site, to reduce request quantity.
 *
 * @param  ID_TEXT			Resource type
 * @set .css .js
 * @param  array				Resources (map of keys to 1), passed by reference as we alter it
 * @param  BINARY				If we are minifying
 * @param  BINARY				If we are using HTTPs
 * @param  BINARY				If we are using mobile
 * @return ?ID_TEXT			Resource name for merged file, which we assume is compiled (as this function makes it) (NULL: we don't know what is required / race condition)
 */
function _handle_web_resource_merging($type,&$arr,$minify,$https,$mobile)
{
	if (!$minify) return; // Optimisation disabled if no minification. Turn off minificiation when debugging Javascript/CSS, as smart caching won't work with the merge system.

	$is_admin=$GLOBALS['FORUM_DRIVER']->is_super_admin(get_member());
	$zone_name=get_zone_name();

	$grouping_codename_welcome='merged__';
	$grouping_codename_welcome.='';
	if ($is_admin) $grouping_codename_welcome.='__admin';

	$grouping_codename='merged__';
	$grouping_codename.=$zone_name;
	if ($is_admin) $grouping_codename.='__admin';

	$value=get_value_newer_than($grouping_codename.$type,time()-60*60*24);

	if ($zone_name!='')
	{
		$welcome_value=get_value_newer_than($grouping_codename_welcome.$type,time()-60*60*24);
		if (is_null($welcome_value)) return NULL; // Don't do this if we haven't got for welcome zone yet (we try and make all same as welcome zone if possible - so we need it to compare against)
	} else
	{
		$welcome_value=$value;
	}

	// If not set yet, work out what merge situaton would be and save it
	if ((is_null($value)) || (strpos($value,'::')===false))
	{
		$is_guest=is_guest();

		// If is zone front page
		if (get_zone_default_page($zone_name)==get_page_name())
		{
			// If in guest group or admin group
			if (($is_guest) || ($is_admin))
			{
				// Work out a hash (checksum) for cache busting on this merged file. Does it using an mtime has chain for performance (better than reading and hashing all the file contents)
				$hash='';
				$resources=array_keys($arr);
				foreach ($resources as $resource)
				{
					if ($resource=='no_cache') continue;

					if ($type=='.js')
					{
						$merge_from=javascript_enforce($resource);
					} else // .css
					{
						$merge_from=css_enforce($resource);
					}
					if ($merge_from!='') $hash=substr(md5($hash.@strval(filemtime($merge_from))),0,5);
				}

				$value=implode(',',$resources).'::'.$hash;
				set_value($grouping_codename.$type,$value);
			}
		}
	}

	// If set, ensure merged resources file exists, and apply it
	if (!is_null($value))
	{
		if ($welcome_value==$value) // Optimisation, if same as welcome zone, use that -- so user does not need to download multiple identical merged resources
		{
			$grouping_codename=$grouping_codename_welcome;
		}

		$_value=explode('::',$value);
		$resources=explode(',',$_value[0]);
		$hash=$_value[1];

		// Find merged file path
		$theme=filter_naughty($GLOBALS['FORUM_DRIVER']->get_theme());
		$dir=get_custom_file_base().'/themes/'.$theme.'/templates_cached/'.filter_naughty(user_lang());
		$grouping_codename.='_'.$hash; // Add cache buster component
		$file=$grouping_codename;
		if (!$minify) $file.='_non_minified';
		if ($https) $file.='_ssl';
		if ($mobile) $file.='_mobile';
		$write_path=$dir.'/'.filter_naughty_harsh($file);
		$write_path.=$type;

		if (!is_file($write_path))
		{
			// Create merged resource...

			$data='';
			$good_to_go=true;
			foreach ($resources as $resource)
			{
				if ($resource=='no_cache') continue;

				if ($type=='.js')
				{
					$merge_from=javascript_enforce($resource);
				} else // .css
				{
					$merge_from=css_enforce($resource);
				}
				if (is_file($merge_from))
				{
					$data.=unixify_line_format(file_get_contents($merge_from)).chr(10).chr(10);
				} else // race condition
				{
					$good_to_go=false;
					break;
				}
			}

			if ($good_to_go)
			{
				$myfile=@fopen($write_path,'wb') OR intelligent_write_error($write_path); // Intentionally 'wb' to stop line ending conversions on Windows
				fwrite($myfile,$data);
				fclose($myfile);
				fix_permissions($write_path,0777);
				sync_file($write_path);
			}
		} else
		{
			$good_to_go=true;
		}

		if ($good_to_go)
		{
			foreach ($resources as $resource)
			{
				if ($resource=='no_cache') continue;

				unset($arr[$resource]); // Don't load up if unit already individually requested
			}
			$arr[$grouping_codename]=0; // Add in merge one to load instead

			return $grouping_codename;
		}
	}

	return NULL;
}

/**
 * Provides a hook for file synchronisation between mirrored servers. Called after any file creation, deletion or edit.
 *
 * @param  PATH				File/directory name to sync on (full path)
 */
function sync_file($filename)
{
	global $FILE_BASE,$_MODIFIED_FILES,$_CREATED_FILES;
	static $has_sync_script=NULL;
	if (is_null($has_sync_script)) $has_sync_script=is_file($FILE_BASE.'/data_custom/sync_script.php');
	if ((!$has_sync_script) && (!isset($_MODIFIED_FILES))) return;
	if (substr($filename,0,strlen($FILE_BASE)+1)==$FILE_BASE.'/')
	{
		$filename=substr($filename,strlen($FILE_BASE)+1);
	}
	if ($has_sync_script)
	{
		require_once($FILE_BASE.'/data_custom/sync_script.php');
		if (function_exists('master__sync_file')) master__sync_file($filename);
	}
	if (isset($_MODIFIED_FILES))
		foreach ($_MODIFIED_FILES as $i=>$x)
			if (($x==$FILE_BASE.'/'.$filename) || ($x==$filename)) unset($_MODIFIED_FILES[$i]);
	if (isset($_CREATED_FILES))
		foreach ($_CREATED_FILES as $i=>$x)
			if (($x==$FILE_BASE.'/'.$filename) || ($x==$filename)) unset($_CREATED_FILES[$i]);
}

/**
 * Provides a hook for file-move synchronisation between mirrored servers. Called after any rename or move action.
 *
 * @param  PATH				File/directory name to move from (may be full or relative path)
 * @param  PATH				File/directory name to move to (may be full or relative path)
 */
function sync_file_move($old,$new)
{
	require_code('files2');
	_sync_file_move($old,$new);
}

/**
 * Performs lots of magic to make sure data encodings are converted correctly. Input, and output too (as often stores internally in UTF or performs automatic dynamic conversions from internal to external charsets).
 * Roll on PHP6 that has a true internal UTF string model. For now, anyone who uses UTF will get some (albeit minor) imperfections from PHP's manipulations of the strings.
 *
 * @param  boolean				Whether we know we are working in UTF-8. This is the case for AJAX calls.
 */
function convert_data_encodings($known_utf8=false)
{
	global $VALID_ENCODING,$CONVERTED_ENCODING;
	$VALID_ENCODING=true;

	if ($CONVERTED_ENCODING) return; // Already done it
	if ((array_key_exists('KNOWN_UTF8',$GLOBALS)) && ($GLOBALS['KNOWN_UTF8'])) $known_utf8=true;

	$charset=get_charset();

	$done_something=false;

	// Conversion of parameters that might be in the wrong character encoding (e.g. Javascript uses UTF to make requests regardless of document encoding, so the stuff needs converting)
	//  If we don't have any PHP extensions (mbstring etc) that can perform the detection/conversion, our code will take this into account and use utf8_decode at points where it knows that it's being communicated with by Javascript.
	if (@strlen(ini_get('unicode.runtime_encoding'))>0)
	{
		@ini_set('default_charset',$charset);
		@ini_set('unicode.runtime_encoding',$charset);
		@ini_set('unicode.output_encoding',$charset);
		@ini_set('unicode.semantics','1');

		$done_something=true;
	}
	elseif (($known_utf8) && /*test method works...*/(will_be_unicode_neutered(serialize($_GET).serialize($_POST))) && (in_array(strtolower($charset),array('iso-8859-1','iso-8859-15','koi8-r','big5','gb2312','big5-hkscs','shift_jis','euc-jp')))) // Preferred as it will sub entities where there's no equivalent character
	{
		require_code('character_sets');

		do_environment_utf8_conversion($charset);

		$done_something=true;
	}
	elseif ((function_exists('iconv_set_encoding')) && (get_value('disable_iconv')!=='1'))
	{
		$encoding=$known_utf8?'UTF-8':$charset;
		if (@iconv_set_encoding('input_encoding',$encoding))
		{
			iconv_set_encoding('output_encoding',$charset);
			iconv_set_encoding('internal_encoding',$charset);
		} else
		{
			$VALID_ENCODING=false;
		}

		$done_something=true;
	}
	elseif ((function_exists('mb_convert_encoding')) && (get_value('disable_mbstring')!=='1'))
	{
		if (function_exists('mb_list_encodings'))
		{
			$VALID_ENCODING=in_array(strtolower($charset),array_map('strtolower',mb_list_encodings()));
		} else $VALID_ENCODING=true;

		if ($VALID_ENCODING)
		{
			$encoding=$known_utf8?'UTF-8':'';
			if ((function_exists('mb_http_input')) && ($encoding==''))
			{
				if (count($_POST)!=0)
				{
					$encoding=mb_http_input('P');
					if ((!is_string($encoding)) || ($encoding=='pass')) $encoding='';
				}
			}
			if ((function_exists('mb_http_input')) && ($encoding==''))
			{
				$encoding=mb_http_input('G');
				if ((!is_string($encoding)) || ($encoding=='pass')) $encoding='';
				if ((function_exists('mb_detect_encoding')) && ($encoding=='') && (ocp_srv('REQUEST_URI')!=''))
				{
					$encoding=mb_detect_encoding(urldecode(ocp_srv('REQUEST_URI')),$charset.',UTF-8,ISO-8859-1');
					if ((!is_string($encoding)) || ($encoding=='pass')) $encoding='';
				}
			}
			if ($encoding!='')
			{
				foreach ($_GET as $key=>$val)
				{
					if (is_string($val))
					{
						$_GET[$key]=mb_convert_encoding($val,$charset,$encoding);
					} elseif (is_array($val))
					{
						foreach ($val as $i=>$v)
						{
							$_GET[$key][$i]=mb_convert_encoding($v,$charset,$encoding);
						}
					}
				}
				foreach ($_POST as $key=>$val)
				{
					if (is_string($val))
					{
						$_POST[$key]=mb_convert_encoding($val,$charset,$encoding);
					} elseif (is_array($val))
					{
						foreach ($val as $i=>$v)
						{
							$_POST[$key][$i]=mb_convert_encoding($v,$charset,$encoding);
						}
					}
				}
			}
			if (function_exists('mb_http_output')) mb_http_output($charset);
		}

		$done_something=true;
	}
	elseif (($known_utf8) && (strtolower($charset)!='utf-8') && (strtolower($charset)!='utf8')) // This is super-easy, but it's imperfect as it assumes ISO-8859-1 -- hence our worst option
	{
		require_code('character_sets');

		do_simple_environment_utf8_conversion();

		$done_something=true;
	}

	if ($done_something) $CONVERTED_ENCODING=true;
}

/**
 * Guard for entity_utf8_decode. Checks that the data can be stripped so there is no unicode left. Either the htmlentities function must convert mechanically to entity-characters or all higher ascii character codes (which are actually unicode control codes in a unicode interpretation) that are used happen to be linked to named entities.
 *
 * @param  string					Data to check.
 * @return boolean				Whether we are good to execute entity_utf8_decode.
 */
function will_be_unicode_neutered($data)
{
	$data=@htmlentities($data,ENT_COMPAT,'UTF-8');
	if ($data=='') return false; // Some servers fail at the first step
	for ($i=0;$i<strlen($data);$i++)
	{
		if (ord($data[$i])>0x7F) return false;
	}
	return true;
}

/**
 * Convert a unicode character number to a unicode string. Callback for preg_replace.
 *
 * @param  array					Regular expression match array.
 * @return ~string				Converted data (false: could not convert).
 */
function unichrm_hex($matches)
{
	return unichr(hexdec($matches[1]));
}

/**
 * Convert a unicode character number to a unicode string. Callback for preg_replace.
 *
 * @param  array					Regular expression match array.
 * @return ~string				Converted data (false: could not convert).
 */
function unichrm($matches)
{
	return unichr(intval($matches[1]));
}

/**
 * Convert a unicode character number to a HTML-entity enabled string, using lower ASCII characters where possible.
 *
 * @param  integer				Character number.
 * @return ~string				Converted data (false: could not convert).
 */
function unichr($c)
{
	if ($c<=0x7F)
	{
		return chr($c);
	} else
	{
		return '#&'.strval($c).';';
	}
}

/**
 * Should be called when an action happens that results in content submission. Does a spammer check.
 *
 * @param ?string		Check this particular username that has just been supplied (NULL: none)
 * @param ?string		Check this particular email address that has just been supplied (NULL: none)
 */
function inject_action_spamcheck($username=NULL,$email=NULL)
{
	// Check RBL's/stopforumspam
	$spam_check_level=get_option('spam_check_level',true);
	if (($spam_check_level==='EVERYTHING') || ($spam_check_level==='ACTIONS') || ($spam_check_level==='GUESTACTIONS') && (is_guest()))
	{
		require_code('antispam');
		check_rbls();
		check_stopforumspam($username,$email);
	}
}
