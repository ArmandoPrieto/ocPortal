<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2013

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * Standard code module initialisation function.
 */
function init__content_fs()
{
	require_code('urls2');
	require_code('occle');
}

/**
 * Get the OccLE-fs object for a content type.
 *
 * @param  ID_TEXT	The content type
 * @return ?object	The object (NULL: could not get one)
 */
function get_content_occlefs_object($content_type)
{
	require_code('content');
	$object=get_content_object($content_type);
	if (is_null($object)) return NULL;
	$info=$object->info();
	$fs_hook=$object->occle_filesystem_hook;
	if (is_null($fs_hook)) return NULL;

	require_code('hooks/systems/occle_fs/'.filter_naughty_harsh($content_type));
	$fs_object=object_factory('Hook_occle_fs_'.filter_naughty_harsh($content_type),true);
	if (is_null($fs_object)) return NULL;
	return $fs_object;
}

/**
 * Convert a local ID to something portable.
 *
 * @param  ID_TEXT	The content type
 * @param  ID_TEXT	The content ID
 * @return array		Portable ID details
 */
function remap_content_id_as_portable($content_type,$content_id)
{
	return array(
		'guid'=>TODO,
		'label'=>TODO,
		'id'=>$content_id
	);
}

/**
 * Convert a portable ID to something local.
 *
 * @param  ID_TEXT	The content type
 * @param  array		Portable ID details
 * @return ID_TEXT	The content ID
 */
function remap_portable_as_content_id($content_type,$portable)
{
	// TODO
	$content_id=$portable['id'];
	return $content_id;
}

class content_fs_base
{
	var $folder_content_type=NULL;
	var $file_content_type=NULL;
	var $_cma_object=array();

	/**
	 * Get the file content info for this OccleFS content hook.
	 *
	 * @param  ID_TEXT	The content type
	 * @return object		The object
	 */
	function _get_cma_info($content_type)
	{
		if (!array_key_exists($content_type,$this->_cma_object))
		{
			require_code('content');
			$this->_cma_object[$content_type]=get_content_object($content_type);
		}
		return $this->_cma_object[$content_type]->info();
	}

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?string	The value (NULL: NULL value)
	 */
	function _default_property_str($properties,$property)
	{
		return array_key_exists($property,$properties)?$properties[$property]:'';
	}

	/**
	 * Find a default property, defaulting to NULL.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?string	The value (NULL: NULL value)
	 */
	function _default_property_str_null($properties,$property)
	{
		return array_key_exists($property,$properties)?$properties[$property]:NULL;
	}

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?integer	The value (NULL: NULL value)
	 */
	function _default_property_int($properties,$property)
	{
		return array_key_exists($property,$properties)?intval($properties[$property]):0;
	}

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?integer	The value (NULL: NULL value)
	 */
	function _default_property_int_null($properties,$property)
	{
		return array_key_exists($property,$properties)?intval($properties[$property]):NULL;
	}

	/**
	 * Find a default property, defaulting to the average of what is there already, or the given default if really necessary.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @param  ID_TEXT	The table to average within
	 * @param  integer	The last-resort default
	 * @param  ?ID_TEXT	The database property (NULL: same as $property)
	 * @return integer	The value
	 */
	function _default_property_int_modeavg($properties,$property,$table,$default,$db_property=NULL)
	{
		if (is_null($db_property)) $db_property=$property;

		if (array_key_exists($property,$properties))
		{
			return intval($properties[$property]);
		}

		$db=$GLOBALS[(substr($table,0,2)=='f_')?'FORUM_DB':'SITE_DB'];
		$val=$db->query_value_if_there('SELECT '.$db_property.',count('.$db_property.') AS qty FROM '.get_table_prefix().$table.' GROUP BY '.$db_property.' ORDER BY qty DESC',false,true); // We need the mode here, not the mean
		if (!is_null($val)) return $val;

		return $default;
	}

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  ID_TEXT	The category value (blank: root)
	 * @return ?integer	The category (NULL: root)
	 */
	function _integer_category($category)
	{
		return ($category=='')?NULL:intval($category);
	}

	/**
	 * Get the filename for a content ID. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The content type
	 * @param  ID_TEXT	The content ID
	 * @return ID_TEXT	The filename
	 */
	function _file_convert_id_to_filename($content_type,$content_id)
	{
		return $content_id.'.xml';
	}

	/**
	 * Get the content ID for a filename. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The filename, or filepath
	 * @param  ?ID_TEXT	The content type (NULL: assumption of only one folder content type for this hook; only passed as non-NULL from overridden functions within hooks that are calling this as a helper function)
	 * @return array		A pair: The content type, the content ID
	 */
	function _file_convert_filename_to_id($filename,$content_type=NULL)
	{
		if (is_null($content_type)) $content_type=$this->folder_content_type;

		$content_id=basename($filename,'.xml'); // Remove file extension from filename
		return array($content_type,$content_id);
	}

	/**
	 * Get the filename for a content ID. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The content type
	 * @param  ID_TEXT	The content ID
	 * @return ID_TEXT	The filename
	 */
	function _folder_convert_id_to_filename($content_type,$content_id)
	{
		if ($content_id=='') return '<blank>';
		return $content_id;
	}

	/**
	 * Get the content ID for a filename. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The filename, or filepath
	 * @param  ?ID_TEXT	The content type (NULL: assumption of only one folder content type for this hook; only passed as non-NULL from overridden functions within hooks that are calling this as a helper function)
	 * @return array		A pair: The content type, the content ID
	 */
	function _folder_convert_filename_to_id($filename,$content_type=NULL)
	{
		if (is_null($content_type)) $content_type=$this->folder_content_type;

		if ($filename=='<blank>') $filename='';
		$content_id=basename($filename); // Get filename component from path
		return array($content_type,$content_id);
	}

	/**
	 * Interpret the input of a folder, into a way we can understand it to add. Hooks may override this with special import code.
	 *
	 * @param  SHORT_TEXT	Filename OR Content label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			A pair: the content label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 */
	function _folder_magic_filter($filename,$path,$properties)
	{
		return array($filename,$properties); // Default implementation is simply to assume the filename is the content label, and leave properties alone
	}

	/**
	 * Interpret the input of a file, into a way we can understand it to add. Hooks may override this with special import code.
	 *
	 * @param  SHORT_TEXT	Filename OR Content label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			A pair: the content label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 */
	function _file_magic_filter($filename,$path,$properties)
	{
		return array($filename,$properties); // Default implementation is simply to assume the filename is the content label, and leave properties alone
	}

	function set_properties_via_cloning($id,$from_id)
	{
		// TODO
	}

	function set_properties_via_import($id,$file_path)
	{
		// TODO
	}

	function set_property($id,$key,$val)
	{
		// TODO
	}

	function set_content_access($id,$groups)
	{
		// TODO
	}

	function set_content_privileges_from_preset($id,$group_presets,$assume_full_group_coverage=true)
	{
		// TODO
	}

	function set_content_privileges($id,$group_settings,$assume_full_group_coverage=true)
	{
		// TODO
	}

	function get_content_privileges($id)
	{
		// TODO
	}

	function set_content_privileges_from_preset__member($id,$member_preset)
	{
		// TODO
	}

	function set_content_privileges__member($id,$privilege,$setting)
	{
		// TODO
	}

	function get_content_privileges__member($id)
	{
		// TODO
	}

	/**
	 * Whether the filesystem hook is active.
	 *
	 * @return boolean		Whether it is
	 */
	function _is_active()
	{
		return true;
	}

	/**
	 * Find whether a kind of content handled by this hook (folder or file) can be under a particular kind of folder.
	 *
	 * @param  ID_TEXT		Folder content type
	 * @param  ID_TEXT		Content type (may be file or folder)
	 * @return boolean		Whether it can
	 */
	function _has_parent_child_relationship($above,$under)
	{
		return true;
	}

	/**
	 * Standard modular listing function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  array		The current directory listing
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return ~array		The final directory listing (false: failure)
	 */
	function listing($meta_dir,$meta_root_node,$current_dir,&$occle_fs)
	{
		if (!$this->_is_active()) return false;

		$listing=array();

		$folder_types=is_array($this->folder_content_type)?$this->folder_content_type:(is_null($this->folder_content_type)?array():array($this->folder_content_type));
		$file_types=is_array($this->file_content_type)?$this->file_content_type:(is_null($this->file_content_type)?array():array($this->file_content_type));

		// Find where we're at
		$cat_id=mixed();
		$cat_content_type=mixed();
		if (count($meta_dir)!=0)
		{
			if (is_null($this->folder_content_type)) return false; // Should not be possible

			list($cat_content_type,$_cat_id)=$this->_file_convert_filename_to_id(implode('/',$meta_dir));
			$cat_id=($folder_info['id_field_numeric']?intval($_cat_id):$_cat_id)
		} else
		{
			if (!is_null($this->folder_content_type))
			{
				$cat_id=($folder_info['id_field_numeric']?NULL:'');
				$cat_content_type=is_array($this->folder_content_type)?$this->folder_content_type[0]:$this->folder_content_type;
			}
		}

		// Find folders
		foreach ($folder_types as $content_type)
		{
			if (!_has_parent_child_relationship($cat_content_type,$content_type)) continue;

			$folder_info=_get_cma_info($content_type);
			$select=array('main.'.$folder_info['parent_spec__field_name']);
			$table=$folder_info['parent_spec__table_name'].' main';
			if ($folder_info['parent_spec__table_name']!=$folder_info['table'])
			{
				$table.=' JOIN '.$folder_info['table'].' cats ON cats.'.$folder_info['id_field'].'=main.'.$folder_info['parent_spec__table_name'];
				if (!is_null($folder_info['add_time_field'])) $select[]='cats.'.$folder_info['add_time_field'];
				if (!is_null($folder_info['edit_time_field'])) $select[]='cats.'.$folder_info['edit_time_field'];
			} else
			{
				if (!is_null($folder_info['add_time_field'])) $select[]=$folder_info['add_time_field'];
				if (!is_null($folder_info['edit_time_field'])) $select[]=$folder_info['edit_time_field'];
			}
			$extra='';
			if ((is_string($folder_info['id_field'])) && (can_arbitrary_groupby()))
				$extra.='GROUP BY '.$folder_info['id_field'].' '; // In case it's not a real category table, just an implied one by self-categorisation of entries
			$extra.='ORDER BY main.'.$folder_info['parent_spec__field_name'];
			$child_folders=$folder_info['connection']->query_select($table,$select,array('main.'.$folder_info['parent_category_field']=>$cat_id),$extra,10000/*Reasonable limit*/);
			foreach ($child_folders as $folder)
			{
				$file=$this->_folder_convert_id_to_filename($content_type,$folder[$folder_info['parent_spec__field_name']]);

				$filetime=mixed();
				if (!is_null($folder_info['edit_time_field']))
				{
					$filetime=$folder[$folder_info['edit_time_field']];
				}
				if (is_null($filetime))
				{
					if (!is_null($folder_info['add_time_field']))
					{
						$filetime=$folder[$folder_info['add_time_field']];
					}
				}

				$listing[]=array(
					$file,
					OCCLEFS_DIR,
					NULL/*don't calculate a filesize*/,
					$filetime,
				);
			}
		}

		// Find files
		foreach ($file_types as $content_type)
		{
			if (!_has_parent_child_relationship($cat_content_type,$content_type)) continue;

			$file_info=_get_cma_info($content_type);
			$where=array();
			if (!is_null($this->folder_content_type))
			{
				$where[is_array($file_info['category_field'])?$file_info['category_field'][0]:$file_info['category_field']]=$cat_id;
			}
			$select=array();
			append_content_select_for_id($select,$file_info);
			if (!is_null($file_info['add_time_field'])) $select[]=$file_info['add_time_field'];
			if (!is_null($file_info['edit_time_field'])) $select[]=$file_info['edit_time_field'];
			$files=$file_info['connection']->query_select($file_info['table'],$select,$where,10000/*Reasonable limit*/);
			foreach ($files as $file)
			{
				$str_id=extract_content_str_id_from_data($file,$file_info);
				$file=$this->_file_convert_id_to_filename($content_type,$str_id);

				$filetime=mixed();
				if (!is_null($file_info['edit_time_field']))
				{
					$filetime=$file[$file_info['edit_time_field']];
				}
				if (is_null($filetime))
				{
					if (!is_null($file_info['add_time_field']))
					{
						$filetime=$file[$file_info['add_time_field']];
					}
				}

				$listing[]=array(
					$file,
					OCCLEFS_FILE,
					NULL/*don't calculate a filesize*/,
					$filetime,
				);
			}
		}

		return $listing;
	}

	/**
	 * Standard modular directory creation function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The new directory name
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function make_directory($meta_dir,$meta_root_node,$new_dir_name,&$occle_fs)
	{
		if (is_null($folder_content_type)) return false;
_folder_add($label,$path,$properties)
		// TODO
	}

	/**
	 * Standard modular directory removal function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The directory name
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function remove_directory($meta_dir,$meta_root_node,$dir_name,&$occle_fs)
	{
		if (is_null($folder_content_type)) return false;
_folder_delete($path)
		// TODO
	}

	/**
	 * Standard modular file removal function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function remove_file($meta_dir,$meta_root_node,$file_name,&$occle_fs)
	{
_file_delete($path)
		// TODO
	}

	/**
	 * Standard modular file reading function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return ~string	The file contents (false: failure)
	 */
	function read_file($meta_dir,$meta_root_node,$file_name,&$occle_fs)
	{
// TODO: We'll be given $properties, need to convert to XML
		// TODO
	}

	/**
	 * Standard modular file writing function for OcCLE FS hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  string		The new file contents
	 * @param  array		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function write_file($meta_dir,$meta_root_node,$file_name,$contents,&$occle_fs)
	{
// TODO: What if XML supplied? Need to parse into $properties
// TODO: Will check if there's something existing in the listing matching the exact name, if not will add (and the filename will actually change due to a new ID being assinged), if so will save into that
_file_add($filename,$path,$properties)
		// TODO
	}
}
