<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2013

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * Hash something as well as possible. Only use this function if the hash is for short-term use, because long-term we don't know if the best hash function will change or not.
 *
 * @param  SHORT_TEXT	What to hash
 * @param  SHORT_TEXT	Salt
 * @return SHORT_TEXT	Hashed result
 */
function best_hash($to_hash,$salt)
{
	// The crypt implementation is quite complex.
	// It md5's $to_hash first because crypt is not binary safe and we need to feed in arbitrary data.
	// It substr's the salt to comply with salt length requirements.

	if ((defined('CRYPT_BLOWFISH')) && (CRYPT_BLOWFISH==1))
	{
		$_salt=substr(md5($salt),0,22).'$';
		return substr(crypt(md5($to_hash),'$2a$07$'.$_salt),strlen($_salt));
	}

	if ((defined('CRYPT_SHA512')) && (CRYPT_SHA512==1))
	{
		$_salt='$6$rounds=5000$'.substr(md5($salt),0,17).'$';
		return substr(crypt(md5($to_hash),$_salt),strlen($_salt));
	}

	return sha1($to_hash.$salt);
}

/**
 * Get a decent randomised salt.
 *
 * @return ID_TEXT		The salt
 */
function produce_salt()
{
	if ((function_exists('openssl_random_pseudo_bytes')) && (get_value('disable_openssl')!=='1'))
	{
		$u=substr(md5(openssl_random_pseudo_bytes(13)),0,13); // md5 so that we get nice ASCII characters
	} else
	{
		$u=substr(md5(uniqid(strval(get_secure_random_number()),true)),0,13);
	}
	return $u;
}

/**
 * Get the site-wide salt. It should be something hard for a hacker to get, so we depend on data gathered both from the database and file-system.
 *
 * @return ID_TEXT		The salt
 */
function get_site_salt()
{
	$site_salt=get_value('site_salt');
	if ($site_salt===NULL)
	{
		$site_salt=produce_salt();
		set_value('site_salt',$site_salt);
	}
	//global $SITE_INFO; This is unstable on some sites, as the array can be prepopulated on the fly
	//$site_salt.=serialize($SITE_INFO);
	return md5($site_salt);
}

/**
 * Check the given master password is valid.
 *
 * @param  SHORT_TEXT	Given master password
 * @return boolean		Whether it is valid
 */
function check_master_password($password_given)
{
	if (isset($GLOBALS['SITE_INFO']['admin_password'])) // LEGACY
	{
		$GLOBALS['SITE_INFO']['master_password']=$GLOBALS['SITE_INFO']['admin_password'];
		unset($GLOBALS['SITE_INFO']['admin_password']);
	}

	global $SITE_INFO;
	if (!array_key_exists('master_password',$SITE_INFO)) exit('No master password defined in _config.php currently so cannot authenticate');
	$actual_password_hashed=$SITE_INFO['master_password'];
	$salt='';
	if ((substr($actual_password_hashed,0,1)=='!') && (strlen($actual_password_hashed)==33))
	{
		$actual_password_hashed=substr($actual_password_hashed,1);
		$salt='ocp';
	}
	return (((strlen($password_given)!=32) && ($actual_password_hashed==$password_given)) || ($actual_password_hashed==md5($password_given.$salt)));
}

/**
 * Get a randomised password.
 *
 * @return string			The randomised password
 */
function get_rand_password()
{
	return produce_salt();
}

/**
 * Get a secure random number, the best this PHP version can do.
 *
 * @return integer		The randomised number
 */
function get_secure_random_number()
{
	// 2147483647 is from MySQL limit http://dev.mysql.com/doc/refman/5.0/en/integer-types.html ; PHP_INT_MAX is higher on 64bit machines
	if ((function_exists('openssl_random_pseudo_bytes')) && (get_value('disable_openssl')!=='1'))
	{
		$code=2147483647*(hexdec(bin2hex(openssl_random_pseudo_bytes(4)))/0xffffffff);
		if ($code<0) $code=-$code;
	} else
	{
		$code=mt_rand(0,min(2147483647,mt_getrandmax()));
	}
	return $code;
}
