<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2014

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    breadcrumbs
 */

/**
 * Load all breadcrumb substitutions and return them.
 *
 * @param  array                        $segments The default breadcrumb segments
 * @param  string                       $data The breadcrumb XML data
 * @return array                        The adjusted breadcrumb segments
 */
function load_breadcrumb_substitutions($segments, $data)
{
    static $substitutions = null;
    if ($substitutions === null) {
        $loader = new Breadcrumb_substitution_loader();
        $loader->go($data);
        $substitutions = $loader->substitutions;
    }

    $segments_new = array();
    $done_one = false;
    foreach ($segments as $i => $segment) {
        if (!$done_one && $segment[0] != '') {
            if (is_object($segment[1])) {
                $segment[1] = $segment[1]->evaluate();
            }

            list($zone, $attributes, $hash) = page_link_decode($segment[0]);

            foreach ($substitutions as $j => $details) {
                if ($details !== null && match_key_match($details[0], false, $attributes, $zone, $attributes['page'])) {
                    if ($details[1] === null || $details[1] == $segment[1]) {
                        $segments_new = $details[2]; // New stem found
                        $done_one = true;

                        $substitutions[$j] = null; // Stop loops
                    }
                }
            }
        }

        $segments_new[] = $segment;
    }

    if ($done_one) {
        return load_breadcrumb_substitutions($segments_new, $data); // Try a new sweep
    }

    return $segments_new;
}

/**
 * Breadcrumb composition class.
 */
class Breadcrumb_substitution_loader
{
    // Used during parsing
    private $tag_stack, $attribute_stack, $text_so_far;
    private $substitution_current_match_key, $substitution_current_label, $substitution_current_links;
    public $substitutions; // output

    /**
     * Run the loader, to load up field-restrictions from the XML file.
     *
     * @param  string                   $data The breadcrumb XML data
     */
    public function go($data)
    {
        $this->tag_stack = array();
        $this->attribute_stack = array();

        $this->substitution_current_match_key = null;
        $this->substitution_current_label = null;
        $this->substitution_current_links = array();

        $this->substitutions = array();

        // Create and setup our parser
        if (function_exists('libxml_disable_entity_loader')) {
            libxml_disable_entity_loader();
        }
        $xml_parser = @xml_parser_create();
        if ($xml_parser === false) {
            return; // PHP5 default build on windows comes with this function disabled, so we need to be able to escape on error
        }
        xml_set_object($xml_parser, $this);
        @xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, get_charset());
        @xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 0);
        xml_set_element_handler($xml_parser, 'startElement', 'endElement');
        xml_set_character_data_handler($xml_parser, 'startText');

        // Run the parser
        if (@xml_parse($xml_parser, $data, true) == 0) {
            attach_message('breadcrumbs.xml: ' . xml_error_string(xml_get_error_code($xml_parser)), 'warn');
            return;
        }
        @xml_parser_free($xml_parser);
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  object                   $parser The parser object (same as 'this')
     * @param  string                   $tag The name of the element found
     * @param  array                    $_attributes Array of attributes of the element
     */
    public function startElement($parser, $tag, $_attributes)
    {
        array_push($this->tag_stack, $tag);
        $tag_attributes = array();
        foreach ($_attributes as $key => $val) {
            $tag_attributes[$key] = $val;
        }
        array_push($this->attribute_stack, $tag_attributes);

        switch ($tag) {
            case 'substitution':
                $_substitution_current_match_key = isset($tag_attributes['match_key']) ? $tag_attributes['match_key'] : '_WILD:_WILD';
                //$this->substitution_current_match_key = page_link_decode($_substitution_current_match_key); match_key_match doesn't actually want it like this
                $this->substitution_current_match_key = array(explode(':', $_substitution_current_match_key));
                $this->substitution_current_label = isset($tag_attributes['label']) ? $tag_attributes['label'] : null;
                $this->substitution_current_links = array();
                break;

            case 'link':
                break;
        }
        $this->text_so_far = '';
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  object                   $parser The parser object (same as 'this')
     * @param  string                   $data The text
     */
    public function startText($parser, $data)
    {
        $this->text_so_far .= $data;
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  object                   $parser The parser object (same as 'this')
     */
    public function endElement($parser)
    {
        $tag = array_pop($this->tag_stack);
        $tag_attributes = array_pop($this->attribute_stack);

        switch ($tag) {
            case 'substitution':
                $this->substitutions[] = array(
                    $this->substitution_current_match_key,
                    $this->substitution_current_label,
                    $this->substitution_current_links
                );
                break;

            case 'link':
                $page_link = trim(str_replace('\n', "\n", $this->text_so_far));
                $this->substitution_current_links[] = array(
                    $page_link,
                    isset($tag_attributes['label']) ? protect_from_escaping(comcode_to_tempcode($tag_attributes['label'])) : new Tempcode()
                );
                break;
        }
    }
}
