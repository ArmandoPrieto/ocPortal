<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2013

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		occle
 */

/*
Resource-fs serves the 'var' parts of OcCLE-fs. It binds OcCLE-fs to a property/XML-based content model.

A programmer can also directly talk to Resource-fs to do abstracted CRUD operations on just about any kind of ocPortal resource.
i.e. Perform generalised operations on resource types without needing to know their individual APIs.

The user knows all of OcCLE-fs as "The ocPortal Repository".
*/

/**
 * Standard code module initialisation function.
 */
function init__resource_fs()
{
	require_code('occle');
}

/**
 * Get the OccLE-fs object for a resource type.
 *
 * @param  ID_TEXT	The resource type
 * @return ?object	The object (NULL: could not get one)
 */
function get_resource_occlefs_object($resource_type)
{
	require_code('content');
	$object=get_content_object($resource_type);
	if (is_null($object)) return NULL;
	$info=$object->info();
	$fs_hook=$object->occle_filesystem_hook;
	if (is_null($fs_hook)) return NULL;

	require_code('hooks/systems/occle_fs/'.filter_naughty_harsh($resource_type));
	$fs_object=object_factory('Hook_occle_fs_'.filter_naughty_harsh($resource_type),true);
	if (is_null($fs_object)) return NULL;
	return $fs_object;
}

/*
ADDRESSING SPACE POPULATION AND LOOKUP CAN HAPPEN OUTSIDE RESOURCE-FS OBJECTS;
THIS INCLUDES FILENAME STUFF, ALTHOUGH DELEGATED INTERNALLY TO THE RESOURCE-FS OBJECT WHICH HANDLES THE ACTUAL NAMING RULES;
ACTUAL FILESYSTEM INTERACTION IS DONE VIA A RESOURCE-FS OBJECT (fetch via get_resource_occlefs_object)
*/

/**
 * Generate, and save, a resource-fs moniker.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The resource ID
 * @param  ?SHORT_TEXT	The (new) label (NULL: lookup for specified resource)
 * @return array			A triple: The moniker (may be new, or the prior one if the moniker did not need to change), the GUID, the label
 */
function generate_resourcefs_moniker($resource_type,$resource_id,$label=NULL)
{
	$resource_object=get_content_object($resource_type);
	$resource_info=$resource_object->info();
	$resourcefs_hook=$resource_info['occle_filesystem_hook'];

	$no_exists_check_for=$GLOBALS['SITE_DB']->query_select_value_if_there('alternative_ids','resource_id',array('resource_type'=>$resource_type,'resource_id'=>$resource_id));

	if (is_null($label))
	{
		require_code('content');
		list($label)=content_get_details($resource_type,$resource_id);
		if (is_null($label)) return array(NULL,NULL);
	}

	require_code('urls2');
	$moniker=_generate_moniker($label);

	// Check it does not already exist
	$moniker_origin=$moniker;
	$next_num=1;
	if (is_numeric($moniker)) $moniker.='_1';
	$test=mixed();
	do
	{
		if (!is_null($no_exists_check_for))
		{
			if ($moniker==$no_exists_check_for) return $moniker; // This one is okay, we know it is safe
		}

		$test=$GLOBALS['SITE_DB']->query_select_value_if_there('alternative_ids','resource_id',array('resource_resourcefs_hook'=>$resourcefs_hook,'resource_moniker'=>$moniker));
		if (!is_null($test)) // Oh dear, will pass to next iteration, but trying a new moniker
		{
			$next_num++;
			$moniker=$moniker_origin.'_'.strval($next_num);
		}
	}
	while (!is_null($test));

	$guid=$GLOBALS['SITE_DB']->query_select_value_if_there('alternative_ids','resource_guid',array('resource_type'=>$resource_type,'resource_id'=>$resource_id));
	if (is_null($guid)) $guid=generate_guid();

	if ($moniker!==$no_exists_check_for)
	{
		$GLOBALS['SITE_DB']->query_delete('alternative_ids',array('resource_type'=>$resource_type,'resource_id'=>$resource_id),'',1);

		$GLOBALS['SITE_DB']->query_insert('alternative_ids',array(
			'resource_type'=>$resource_type,
			'resource_id'=>$resource_id,
			'resource_moniker'=>$moniker,
			'resource_label'=>$label,
			'resource_guid'=>$guid,
			'resource_resourcefs_hook'=>$resourcefs_hook,
		));
	}

	return array($moniker,$guid,$label);
}

/**
 * Generate, and save, a resource-fs moniker.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The resource ID
 */
function expunge_resourcefs_moniker($resource_type,$resource_id)
{
	$GLOBALS['SITE_DB']->query_delete('alternative_ids',array('resource_type'=>$resource_type,'resource_id'=>$resource_id),'',1);
}

/**
 * Find the resource GUID from the resource ID.
 *
 * @param  ID_TEXT	The resource type
 * @param  ID_TEXT	The resource ID
 * @return ?ID_TEXT	The GUID (NULL: no match)
 */
function find_guid_via_id($resource_type,$resource_id)
{
	list(,$guid)=generate_resourcefs_moniker($resource_type,$resource_id);
	return $guid;
}

/**
 * Find the OcCLE-fs (repository) filename from the resource ID.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The resource ID
 * @param  boolean		Whether to include the subpath
 * @return ?ID_TEXT		The filename (NULL: no match)
 */
function find_occlefs_filename_via_id($resource_type,$resource_id,$include_subpath=false)
{
	$resourcefs_ob=get_resource_occlefs_object($resource_type);
	$filename=$resourcefs_ob->convert_id_to_filename($resource_type,$resource_id);
	if (!is_null($filename))
	{
		if ($include_subpath)
		{
			$subpath=$resourcefs_ob->search($resource_type,$resource_id);
			$filename=$subpath.'/'.$filename;
		}
	}
	return $filename;
}

/**
 * Find the resource moniker from the resource ID.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The resource ID
 * @return ?ID_TEXT		The moniker (NULL: no match)
 */
function find_moniker_via_id($resource_type,$resource_id)
{
	list($moniker)=generate_resourcefs_moniker($resource_type,$resource_id);
	return $moniker;
}

/**
 * Find the resource label from the resource ID.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The resource ID
 * @return ?SHORT_TEXT	The label (NULL: no match)
 */
function find_label_via_id($resource_type,$resource_id)
{
	list(,,$label)=generate_resourcefs_moniker($resource_type,$resource_id);
	return $label;
}

/**
 * Find the resource ID from the resource moniker.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The moniker
 * @return ?ID_TEXT		The ID (NULL: no match)
 */
function find_id_via_moniker($resource_type,$resource_moniker)
{
	return $GLOBALS['SITE_DB']->query_select_value_if_there('alternative_ids','resource_id',array(
		'resource_type'=>$resource_type,
		'resource_moniker'=>$resource_moniker,
	));
}

/**
 * Find the resource ID from the resource label.
 *
 * @param  ID_TEXT		The resource type
 * @param  SHORT_TEXT	The label
 * @param  ?string		The subpath (NULL: don't care)
 * @return ?ID_TEXT		The ID (NULL: no match)
 */
function find_id_via_label($resource_type,$label,$subpath=NULL)
{
	$ids=$GLOBALS['SITE_DB']->query_select('alternative_ids',array('resource_id'),array(
		'resource_type'=>$resource_type,
		'resource_label'=>$resource_label,
	));
	$resource_ids=collapse_1d_complexity('resource_id',$ids);
	foreach ($resource_ids as $resource_id)
	{
		if ($subpath===NULL) return $resource_id; // Don't care about path

		// Check path
		$occlefs_ob=get_resource_occlefs_object($resource_type);
		$_subpath=$occlefs_ob->search($resource_type,$resource_id);
		if ($_subpath==$subpath) return $resource_id;
	}
	// No valid match
	return NULL;
}

/**
 * Find the resource ID from the resource GUID. It is assumed you as the programmer already know the resource-type.
 *
 * @param  ID_TEXT		The GUID
 * @return ?ID_TEXT		The ID (NULL: no match)
 */
function find_id_via_guid($guid)
{
	return $GLOBALS['SITE_DB']->query_select_value_if_there('alternative_ids','resource_id',array(
		'resource_guid'=>$resource_guid,
	));
}

/**
 * Find the resource IDs from the resource GUIDs. This is useful if you need to resolve many GUIDs at once during performant-critical code.
 *
 * @param  array			The GUIDs
 * @return array			Mapping between GUIDs and IDs (anything where there's no match will result in no array entry being present for that GUID)
 */
function find_ids_via_guids($guids)
{
	$or_list='';
	foreach ($guids as $guid)
	{
		if ($or_list!='') $or_list.=' OR ';
		$or_list.=db_string_equal_to('resource_guid',$guid);
	}
	$query='SELECT resource_id,resource_guid FROM '.get_table_prefix().'alternative_ids WHERE '.$or_list;
	$ret=$GLOBALS['SITE_DB']->query($query,NULL,NULL,false,true);
	return collapse_2d_complexity('resource_id','resource_guid',$ret);
}

/**
 * Find the resource ID from the OcCLE-fs (repository) filename.
 *
 * @param  ID_TEXT		The resource type
 * @param  ID_TEXT		The filename
 * @return ?ID_TEXT		The ID (NULL: no match)
 */
function find_id_via_occlefs_filename($resource_type,$filename)
{
	$resourcefs_ob=get_resource_occlefs_object($resource_type);
	$test=$resourcefs_ob->convert_filename_to_id($filename,$resource_type);
	if (is_null($test)) return NULL;
	list(,$resource_id)=$test;
	return $resource_id;
}

/**
 * Resource-fs base class.
 * @package		occle
 */
class resource_fs_base
{
	/*
	FINDING INFORMATION ABOUT HOOK STRUCTURE
	*/

	var $folder_resource_type=NULL;
	var $file_resource_type=NULL;
	var $_cma_object=array();

	/**
	 * Get the file resource info for this OcCLE-fs resource hook.
	 *
	 * @param  ID_TEXT	The resource type
	 * @return object		The object
	 */
	function _get_cma_info($resource_type)
	{
		if (!array_key_exists($resource_type,$this->_cma_object))
		{
			require_code('content');
			$this->_cma_object[$resource_type]=get_content_object($resource_type);
		}
		return $this->_cma_object[$resource_type]->info();
	}

	/**
	 * Find whether a resource type is of a folder-type.
	 *
	 * @param  ID_TEXT	The resource type
	 * @return boolean	Whether it is
	 */
	function is_folder_type($resource_type)
	{
		$folder_types=is_array($this->folder_resource_type)?$this->folder_resource_type:(is_null($this->folder_resource_type)?array():array($this->folder_resource_type));
		return in_array($resource_type,$folder_types);
	}

	/**
	 * Find whether a resource type is of a file-type.
	 *
	 * @param  ID_TEXT	The resource type
	 * @return boolean	Whether it is
	 */
	function is_file_type($resource_type)
	{
		$file_types=is_array($this->file_resource_type)?$this->file_resource_type:(is_null($this->file_resource_type)?array():array($this->file_resource_type));
		return in_array($resource_type,$file_types);
	}

	/*
	HOOKS MAY OVERRIDE THESE AS REQUIRED, TO ENCODE IMPLEMENTATION COMPLEXITIES
	*/

	/**
	 * Whether the filesystem hook is active.
	 *
	 * @return boolean		Whether it is
	 */
	function _is_active()
	{
		return true;
	}

	/**
	 * Whether the filesystem hook can handle a particular file type.
	 *
	 * @param  string			The file type (no file extension)
	 * @return array			List of our resource types that can
	 */
	function can_accept_filetype($filetype)
	{
		if ($filetype!='xml') return array();

		$ret=array();
		$ret=array_merge($ret,is_array($this->folder_resource_type)?$this->folder_resource_type:array($this->folder_resource_type));
		$ret=array_merge($ret,is_array($this->file_resource_type)?$this->file_resource_type:array($this->file_resource_type));
		return $ret;
	}

	/**
	 * Find whether a kind of resource handled by this hook (folder or file) can be under a particular kind of folder.
	 *
	 * @param  ID_TEXT		Folder resource type
	 * @param  ID_TEXT		Resource type (may be file or folder)
	 * @return boolean		Whether it can
	 */
	function _has_parent_child_relationship($above,$under)
	{
		return true;
	}

	/**
	 * Load function for resource-fs (for files). Finds the data for some resource from a resource-fs file.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @return ~string		Resource data (false: error)
	 */
	function file_load__flat($filename,$path)
	{
		return $this->file_load_xml($filename,$path); // By default, only defer to the inbuilt ocPortal XML implementation (hooks may override this with support for other kinds of interchange file formats)
	}

	/**
	 * Load function for resource-fs (for folders). Finds the data for some resource from a resource-fs folder.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @return ~string		Resource data (false: error)
	 */
	function folder_load__flat($filename,$path)
	{
		return $this->folder_load_xml($filename,$path); // By default, only defer to the inbuilt ocPortal XML implementation (hooks may override this with support for other kinds of interchange file formats)
	}

	/**
	 * Save function for resource-fs (for files). Parses the data for some resource to a resource-fs file.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @param  string			Resource data
	 * @return boolean		Success status
	 */
	function file_save__flat($filename,$path,$data)
	{
		return $this->file_save_xml($filename,$path,$data); // By default, only defer to the inbuilt ocPortal XML implementation (hooks may override this with support for other kinds of interchange file formats)
	}

	/**
	 * Save function for resource-fs (for folders). Parses the data for some resource to a resource-fs folder.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @param  string			Resource data
	 * @return boolean		Success status
	 */
	function folder_save__flat($filename,$path,$data)
	{
		return $this->folder_save_xml($filename,$path,$data); // By default, only defer to the inbuilt ocPortal XML implementation (hooks may override this with support for other kinds of interchange file formats)
	}

	/**
	 * Interpret the input of a file, into a way we can understand it to add. Hooks may override this with special import code.
	 *
	 * @param  SHORT_TEXT	Filename OR Resource label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			A pair: the resource label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 */
	function _file_magic_filter($filename,$path,$properties)
	{
		return array($filename,$properties); // Default implementation is simply to assume the filename is the resource label, and leave properties alone
	}

	/**
	 * Interpret the input of a folder, into a way we can understand it to add. Hooks may override this with special import code.
	 *
	 * @param  SHORT_TEXT	Filename OR Resource label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			A pair: the resource label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 */
	function _folder_magic_filter($filename,$path,$properties)
	{
		return array($filename,$properties); // Default implementation is simply to assume the filename is the resource label, and leave properties alone
	}

	/**
	 * Get the filename for a resource ID. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The resource type
	 * @param  ID_TEXT	The resource ID
	 * @return ID_TEXT	The filename
	 */
	function file_convert_id_to_filename($resource_type,$resource_id)
	{
		$moniker=find_moniker_via_id($resource_type,$resource_id);
		return $moniker.'.xml';
	}

	/**
	 * Get the filename for a resource ID. Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The resource type
	 * @param  ID_TEXT	The resource ID
	 * @return ?ID_TEXT	The filename (NULL: could not find)
	 */
	function folder_convert_id_to_filename($resource_type,$resource_id)
	{
		return find_moniker_via_id($resource_type,$resource_id);
	}

	/**
	 * Get the resource ID for a filename (of file). Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The filename, or filepath
	 * @param  ?ID_TEXT	The resource type (NULL: assumption of only one folder resource type for this hook; only passed as non-NULL from overridden functions within hooks that are calling this as a helper function)
	 * @return ?array		A pair: The resource type, the resource ID (NULL: could not find)
	 */
	function file_convert_filename_to_id($filename,$resource_type=NULL)
	{
		if (is_null($resource_type)) $resource_type=$this->folder_resource_type;

		$filename=preg_replace('#^.*/#','',$filename); // Paths not needed, as filenames are globally unique; paths would not be in alternative_ids table

		$moniker=basename($filename,'.xml'); // Remove file extension from filename
		$resource_id=find_id_via_moniker($resource_type,$moniker);
		return array($resource_type,$resource_id);
	}

	/**
	 * Get the resource ID for a filename (of folder). Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The filename, or filepath
	 * @param  ?ID_TEXT	The resource type (NULL: assumption of only one folder resource type for this hook; only passed as non-NULL from overridden functions within hooks that are calling this as a helper function)
	 * @return array		A pair: The resource type, the resource ID
	 */
	function folder_convert_filename_to_id($filename,$resource_type=NULL)
	{
		if (is_null($resource_type)) $resource_type=$this->folder_resource_type;

		$filename=preg_replace('#^.*/#','',$filename); // Paths not needed, as filenames are globally unique; paths would not be in alternative_ids table

		$moniker=basename($filename); // Get filename component from path
		$resource_id=find_id_via_moniker($resource_type,$moniker);
		return array($resource_type,$resource_id);
	}

	/*
	JUGGLING PROPERTIES
	*/

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?string	The value (NULL: NULL value)
	 */
	function _default_property_str($properties,$property)
	{
		return array_key_exists($property,$properties)?$properties[$property]:'';
	}

	/**
	 * Find a default property, defaulting to NULL.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?string	The value (NULL: NULL value)
	 */
	function _default_property_str_null($properties,$property)
	{
		return array_key_exists($property,$properties)?$properties[$property]:NULL;
	}

	/**
	 * Find an integer default property, defaulting to NULL.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?integer	The value (NULL: NULL value)
	 */
	function _default_property_int($properties,$property)
	{
		return array_key_exists($property,$properties)?intval($properties[$property]):0;
	}

	/**
	 * Convert a category to an integer, defaulting to NULL if it is blank.
	 *
	 * @param  ID_TEXT	The category value (blank: root)
	 * @return ?integer	The category (NULL: root)
	 */
	function _integer_category($category)
	{
		return ($category=='')?NULL:intval($category);
	}

	/**
	 * Find a default property, defaulting to blank.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @return ?integer	The value (NULL: NULL value)
	 */
	function _default_property_int_null($properties,$property)
	{
		return array_key_exists($property,$properties)?intval($properties[$property]):NULL;
	}

	/**
	 * Find a default property, defaulting to the average of what is there already, or the given default if really necessary.
	 *
	 * @param  array		The properties
	 * @param  ID_TEXT	The property
	 * @param  ID_TEXT	The table to average within
	 * @param  integer	The last-resort default
	 * @param  ?ID_TEXT	The database property (NULL: same as $property)
	 * @return integer	The value
	 */
	function _default_property_int_modeavg($properties,$property,$table,$default,$db_property=NULL)
	{
		if (is_null($db_property)) $db_property=$property;

		if (array_key_exists($property,$properties))
		{
			return intval($properties[$property]);
		}

		$db=$GLOBALS[(substr($table,0,2)=='f_')?'FORUM_DB':'SITE_DB'];
		$val=$db->query_value_if_there('SELECT '.$db_property.',count('.$db_property.') AS qty FROM '.get_table_prefix().$table.' GROUP BY '.$db_property.' ORDER BY qty DESC',false,true); // We need the mode here, not the mean
		if (!is_null($val)) return $val;

		return $default;
	}

	/*
	ABSTRACT/AGNOSTIC RESOURCE-FS API FOR INTERNAL OCPORTAL USE
	*/

	/**
	 * Find the subpath to a resource.
	 *
	 * @param  ID_TEXT		The resource type
	 * @param  ID_TEXT		The resource ID
	 * @return string			The subpath
	 */
	function search($resource_type,$resource_id)
	{
		// TODO, find subpath
	}

	/**
	 * Convert a label to a filename, possibly with auto-creating if needed. This is useful for the ocPortal-side resource-agnostic API.
	 *
	 * @param  SHORT_TEXT	Resource label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  boolean		Whether the content must already exist
	 * @param  ?ID_TEXT		The filename (NULL: not found)
	 */
	function convert_label_to_filename($label,$subpath,$resource_type,$must_already_exist=false)
	{
		$resource_id=$this->convert_label_to_id($label,$subpath,$resource_type,$must_already_exist);
		if (is_null($resource_id)) return NULL;
		return find_occlefs_filename_via_id($resource_type,$resource_id);
	}

	/**
	 * Convert a label to an ID, possibly with auto-creating if needed. This is useful for the ocPortal-side resource-agnostic API.
	 *
	 * @param  SHORT_TEXT	Resource label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  boolean		Whether the content must already exist
	 * @param  ?ID_TEXT		The ID (NULL: not found)
	 */
	function convert_label_to_id($label,$subpath,$resource_type,$must_already_exist=false)
	{
		$resource_id=find_id_via_label($resource_type,$label,$subpath);
		if (is_null($resource_id))
		{
			if (!$must_already_exist)
			{
				// Not found, create...
				$occlefs_ob=get_resource_occlefs_object($resource_type);

				// Create subpath
				if ($subpath!='')
				{
					$subpath_bits=explode('/',$subpath);
					$subpath_above='';
					foreach ($subpath_bits as $subpath_bit)
					{
						$subpath_id=$this->folder_convert_filename_to_id($subpath_bit);
						if (is_null($subpath_id)) // Missing, create folder
						{
							$this->folder_add($subpath_bit,$subpath_above,array());
						}
						if ($subpath_above!='') $subpath_above.='/';
						$subpath_above.=$subpath_bit;
					}
				}

				// Create main resource
				$resource_id=$occlefs_ob->resource_add($resource_type,$label,$subpath,array());
			}
		}
		return $resource_id;
	}

	/**
	 * Get the filename for a resource ID (of file or folder). Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The resource type
	 * @param  ID_TEXT	The resource ID
	 * @return ?ID_TEXT	The filename (NULL: not found)
	 */
	function convert_id_to_filename($resource_type,$resource_id)
	{
		if ($this->is_file_type($resource_type))
			return $this->file_convert_id_to_filename($resource_id,$resource_type);
		if ($this->is_folder_type($resource_type))
			return $this->folder_convert_id_to_filename($resource_id,$resource_type);
		return NULL;
	}

	/**
	 * Get the resource ID for a filename (of file or folder). Note that filenames are unique across all folders in a filesystem.
	 *
	 * @param  ID_TEXT	The filename, or filepath
	 * @param  ID_TEXT	The resource type
	 * @return ?array		A pair: The resource type, the resource ID (NULL: could not find)
	 */
	function convert_filename_to_id($filename,$resource_type)
	{
		if ($this->is_file_type($resource_type))
			return $this->file_convert_filename_to_id($filename,$resource_type);
		if ($this->is_folder_type($resource_type))
			return $this->folder_convert_filename_to_id($filename,$resource_type);
		return NULL;
	}

	/**
	 * Adds some resource with the given label and properties. Wraps file_add/folder_add.
	 *
	 * @param  ID_TEXT		Resource type
	 * @param  SHORT_TEXT	Filename OR Resource label
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 * @return ~ID_TEXT		The resource ID (false: error, could not create via these properties / here)
	 */
	function resource_add($resource_type,$label,$path,$properties)
	{
		if ($this->is_folder_type($resource_type))
		{
			$resource_id=$this->folder_add($label,$path,array());
		} else
		{
			$resource_id=$this->file_add($label,$path,array());
		}
		return $resource_id;
	}

	/**
	 * Finds the properties for some resource. Wraps file_load/folder_load.
	 *
	 * @param  ID_TEXT		Resource type
	 * @param  SHORT_TEXT	Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @return ~array			Details of the resource (false: error)
	 */
	function resource_load($resource_type,$filename,$path)
	{
		if ($this->is_folder_type($resource_type))
		{
			$properties=folder_load($filename,$path);
		} else
		{
			$properties=file_load($filename,$path);
		}
		return $properties;
	}

	/**
	 * Edits the resource to the given properties. Wraps file_edit/folder_edit.
	 *
	 * @param  ID_TEXT		Resource type
	 * @param  ID_TEXT		The filename
	 * @param  string			The path (blank: root / not applicable)
	 * @param  array			Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
	 * @return boolean		Success status
	 */
	function resource_edit($resource_type,$filename,$path,$properties)
	{
		if ($this->is_folder_type($resource_type))
		{
			$status=folder_edit($filename,$path,$properties);
		} else
		{
			$status=file_edit($filename,$path,$properties);
		}
		return $status;
	}

	/**
	 * Deletes the resource. Wraps file_delete/folder_delete.
	 *
	 * @param  ID_TEXT		Resource type
	 * @param  ID_TEXT		The filename
	 * @return boolean		Success status
	 */
	function resource_delete($resource_type,$filename)
	{
		if ($this->is_folder_type($resource_type))
		{
			$status=folder_delete($filename);
		} else
		{
			$status=file_delete($filename);
		}
		return $status;
	}

	/**
	 * Set resource view access on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @param  array			A mapping from group ID to view access
	 */
	function set_resource_access($filename,$groups)
	{
		// TODO
	}

	/**
	 * Get resource view access on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @return array			A mapping from group ID to view access
	 */
	function get_resource_access($filename)
	{
		// TODO
		return array();
	}

	/**
	 * Reset resource privileges on the resource for all usergroups.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 */
	function reset_resource_privileges($filename)
	{
		// TODO
	}

	/**
	 * Set resource privileges from a preset on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @param  array			A mapping from group ID to preset value. Preset values are 0 (read only) to 3 (moderation)
	 */
	function set_resource_privileges_from_preset($filename,$group_presets)
	{
		// TODO
	}

	/**
	 * Set resource privileges on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @param  array			A map between group ID and lists of pairs: privilege, setting
	 */
	function set_resource_privileges($filename,$group_settings)
	{
		// TODO
	}

	/**
	 * Get the resource privileges for the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @return array			A map between group ID and lists of pairs: privilege, setting
	 */
	function get_resource_privileges($filename)
	{
		// TODO
		return array();
	}

	/**
	 * Set resource privileges from a preset so that a member has custom privileges on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @param  array			A mapping from member ID to preset value. Preset values are 0 (read only) to 3 (moderation)
	 */
	function set_resource_privileges_from_preset__members($filename,$member_presets)
	{
		// TODO
	}

	/**
	 * Set a resource privilege so that a member has a custom privilege on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @param  ID_TEXT		The privilege
	 * @param  ID_TEXT		The value
	 * @set 0 1 
	 */
	function set_resource_privileges__members($filename,$privilege,$setting)
	{
		// TODO
	}

	/**
	 * Get the resource privileges for all members that have custom privileges on the resource.
	 *
	 * @param  ID_TEXT		Resource filename (assumed to be of a folder type)
	 * @return array			A list of triples: member ID, privilege, setting
	 */
	function get_resource_privileges__members($filename)
	{
		// TODO
		return array();
	}

	/*
	HELPERS FOR THE ADDRESSING PORTABILITY
	*/

	/**
	 * Convert a local ID to something portable.
	 *
	 * @param  ID_TEXT	The resource type
	 * @param  ID_TEXT	The resource ID
	 * @return array		Portable ID details
	 */
	function remap_resource_id_as_portable($resource_type,$resource_id)
	{
		list($moniker,$guid,$label)=generate_resourcefs_moniker($resource_type,$resource_id);

		$subpath=$this->search($resource_type,$resource_id);

		return array(
			'guid'=>$guid,
			'label'=>$label,
			'subpath'=>$subpath,
			//'moniker'=>$moniker,	Given more effectively with label
			'id'=>$resource_id // Not used, but useful to have anyway for debugging/manual-reflection
		);
	}

	/**
	 * Convert a portable ID to something local.
	 *
	 * @param  ID_TEXT	The resource type
	 * @param  array		Portable ID details
	 * @return ID_TEXT	The resource ID
	 */
	function remap_portable_as_resource_id($resource_type,$portable)
	{
		//$resource_id=$portable['id'];	Would not be portable between sites

		// Ideally, find via GUID
		$resource_id=array_key_exists('guid',$portable)?find_id_via_guid($portable['guid']):NULL;
		if (!is_null($resource_id)) return $resource_id;

		// Otherwise, use the label
		$resource_id=convert_label_to_id($portable['label'],$portable['subpath'],$resource_type);

		return $resource_id;
	}

	/**
	 * Find all translated strings for a language ID. This is used as an intermediate step in creating multi-language serialisations.
	 *
	 * @param  AUTO_LINK		Language ID
	 * @return array			Details
	 */
	function _get_translated_text($lang_id)
	{
		// TODO
	}

	/*
	XML FILE HANDLING: OUR DEFAULT PROPERTY LIST SERIALISATION/DESERIALISATION
	*/

	/**
	 * Load function for resource-fs (for files). Finds the data for some resource from a resource-fs XML file.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @return ~string		Resource data (false: error)
	 */
	function file_load_xml($filename,$path)
	{
		$properties=$this->file_load($filename,$path);
		if ($properties===false) return false;
		return serialize($properties); // TODO: Should be XML serialisation
	}

	/**
	 * Load function for resource-fs (for folders). Finds the data for some resource from a resource-fs XML folder.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @return ~string		Resource data (false: error)
	 */
	function folder_load_xml($filename,$path)
	{
		$properties=$this->folder_load($filename,$path);
		if ($properties===false) return false;
		return serialize($properties); // TODO: Should be XML serialisation
	}

	/**
	 * Save function for resource-fs (for files). Parses the data for some resource to a resource-fs XML file.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @param  string			Resource data
	 * @return boolean		Success status
	 */
	function file_save_xml($filename,$path,$data)
	{
		$properties=@unserialize($data); // TODO: Should be XML parsing
		if ($properties===false) return false;
		return $this->file_save($filename,$path,$properties);
	}

	/**
	 * Save function for resource-fs (for folders). Parses the data for some resource to a resource-fs XML folder.
	 *
	 * @param  ID_TEXT		Filename
	 * @param  string			The path (blank: root / not applicable)
	 * @param  string			Resource data
	 * @return boolean		Success status
	 */
	function folder_save_xml($filename,$path,$data)
	{
		$properties=@unserialize($data); // TODO: Should be XML parsing
		if ($properties===false) return false;
		return $this->folder_save($filename,$path,$properties);
	}

	/*
	OCCLE-FS BINDING
	*/

	/**
	 * Standard modular listing function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  array		The current directory listing
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return ~array		The final directory listing (false: failure)
	 */
	function listing($meta_dir,$meta_root_node,$current_dir,&$occle_fs)
	{
		if (!$this->_is_active()) return false;

		$listing=array();

		$folder_types=is_array($this->folder_resource_type)?$this->folder_resource_type:(is_null($this->folder_resource_type)?array():array($this->folder_resource_type));
		$file_types=is_array($this->file_resource_type)?$this->file_resource_type:(is_null($this->file_resource_type)?array():array($this->file_resource_type));

		// Find where we're at
		$cat_id=mixed();
		$cat_resource_type=mixed();
		if (count($meta_dir)!=0)
		{
			if (is_null($this->folder_resource_type)) return false; // Should not be possible

			list($cat_resource_type,$_cat_id)=$this->file_convert_filename_to_id(implode('/',$meta_dir));
			$cat_id=($folder_info['id_field_numeric']?intval($_cat_id):$_cat_id)
		} else
		{
			if (!is_null($this->folder_resource_type))
			{
				$cat_id=($folder_info['id_field_numeric']?NULL:'');
				$cat_resource_type=is_array($this->folder_resource_type)?$this->folder_resource_type[0]:$this->folder_resource_type;
			}
		}

		// Find folders
		foreach ($folder_types as $resource_type)
		{
			if (!_has_parent_child_relationship($cat_resource_type,$resource_type)) continue;

			$folder_info=_get_cma_info($resource_type);
			$select=array('main.'.$folder_info['parent_spec__field_name']);
			$table=$folder_info['parent_spec__table_name'].' main';
			if ($folder_info['parent_spec__table_name']!=$folder_info['table'])
			{
				$table.=' JOIN '.$folder_info['table'].' cats ON cats.'.$folder_info['id_field'].'=main.'.$folder_info['parent_spec__table_name'];
				if (!is_null($folder_info['add_time_field'])) $select[]='cats.'.$folder_info['add_time_field'];
				if (!is_null($folder_info['edit_time_field'])) $select[]='cats.'.$folder_info['edit_time_field'];
			} else
			{
				if (!is_null($folder_info['add_time_field'])) $select[]=$folder_info['add_time_field'];
				if (!is_null($folder_info['edit_time_field'])) $select[]=$folder_info['edit_time_field'];
			}
			$extra='';
			if ((is_string($folder_info['id_field'])) && (can_arbitrary_groupby()))
				$extra.='GROUP BY '.$folder_info['id_field'].' '; // In case it's not a real category table, just an implied one by self-categorisation of entries
			$extra.='ORDER BY main.'.$folder_info['parent_spec__field_name'];
			$child_folders=$folder_info['connection']->query_select($table,$select,array('main.'.$folder_info['parent_category_field']=>$cat_id),$extra,10000/*Reasonable limit*/);
			foreach ($child_folders as $folder)
			{
				$file=$this->folder_convert_id_to_filename($resource_type,$folder[$folder_info['parent_spec__field_name']]);

				$filetime=mixed();
				if (method_exists($this,'_get_folder_edit_date'))
				{
					$filetime=$this->_get_folder_edit_date($folder,end($meta_dir));
				}
				if (is_null($filetime))
				{
					if (!is_null($folder_info['edit_time_field']))
					{
						$filetime=$folder[$folder_info['edit_time_field']];
					}
					if (is_null($filetime))
					{
						if (!is_null($folder_info['add_time_field']))
						{
							$filetime=$folder[$folder_info['add_time_field']];
						}
					}
				}

				$listing[]=array(
					$file,
					OCCLEFS_DIR,
					NULL/*don't calculate a filesize*/,
					$filetime,
				);
			}
		}

		// Find files
		foreach ($file_types as $resource_type)
		{
			if (!_has_parent_child_relationship($cat_resource_type,$resource_type)) continue;

			$file_info=_get_cma_info($resource_type);
			$where=array();
			if (!is_null($this->folder_resource_type))
			{
				$where[is_array($file_info['category_field'])?$file_info['category_field'][0]:$file_info['category_field']]=$cat_id;
			}
			$select=array();
			append_content_select_for_id($select,$file_info);
			if (!is_null($file_info['add_time_field'])) $select[]=$file_info['add_time_field'];
			if (!is_null($file_info['edit_time_field'])) $select[]=$file_info['edit_time_field'];
			$files=$file_info['connection']->query_select($file_info['table'],$select,$where,10000/*Reasonable limit*/);
			foreach ($files as $file)
			{
				$str_id=extract_content_str_id_from_data($file,$file_info);
				$file=$this->file_convert_id_to_filename($resource_type,$str_id);

				$filetime=mixed();
				if (method_exists($this,'_get_file_edit_date'))
				{
					$filetime=$this->_get_file_edit_date($file,end($meta_dir));
				}
				if (is_null($filetime))
				{
					if (!is_null($file_info['edit_time_field']))
					{
						$filetime=$file[$file_info['edit_time_field']];
					}
					if (is_null($filetime))
					{
						if (!is_null($file_info['add_time_field']))
						{
							$filetime=$file[$file_info['add_time_field']];
						}
					}
				}

				$listing[]=array(
					$file,
					OCCLEFS_FILE,
					NULL/*don't calculate a filesize*/,
					$filetime,
				);
			}
		}

		return $listing;
	}

	/**
	 * Standard modular directory creation function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The new directory name
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function make_directory($meta_dir,$meta_root_node,$new_dir_name,&$occle_fs)
	{
		if (is_null($folder_resource_type)) return false;
		// TODO
	}

	/**
	 * Standard modular directory removal function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The directory name
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function remove_directory($meta_dir,$meta_root_node,$dir_name,&$occle_fs)
	{
		if (is_null($folder_resource_type)) return false;
		// TODO
	}

	/**
	 * Standard modular file removal function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function remove_file($meta_dir,$meta_root_node,$file_name,&$occle_fs)
	{
		// TODO
	}

	/**
	 * Standard modular file reading function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return ~string	The file contents (false: failure)
	 */
	function read_file($meta_dir,$meta_root_node,$file_name,&$occle_fs)
	{
		// TODO
	}

	/**
	 * Standard modular file writing function for OcCLE-fs hooks.
	 *
	 * @param  array		The current meta-directory path
	 * @param  string		The root node of the current meta-directory
	 * @param  string		The file name
	 * @param  string		The new file contents
	 * @param  object		A reference to the OcCLE filesystem object
	 * @return boolean	Success?
	 */
	function write_file($meta_dir,$meta_root_node,$file_name,$contents,&$occle_fs)
	{
		// TODO
	}
}
