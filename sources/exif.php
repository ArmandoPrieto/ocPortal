<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2011

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * Get meta data from an image, using EXIF primarily, but also XMP and IPTC to get image descriptions.
 * Also gets GPS data and canonicalises in decimal as Latitude and Longitude.
 *
 * @param  string		This is the filename of the photo which may contain metadata
 * @return array		Map of meta data, using standard EXIF naming
 */
function get_exif_data($path)
{
	$out=array();

	if (function_exists('exif_read_data'))
	{
		$out+=@exif_read_data($path,'ANY_TAG');
	}

	$caption=_get_image_caption($path);
	$out['UserComment']=$caption;
	$out+=_get_simple_gps($out);

	return $out;
}

/**
 * Work out canonical Latitude/Longitude details from complex EXIF bits.
 *
 * @param  array		EXIF data
 * @return array		Extra derived EXIF data
 */
function _get_simple_gps($exif)
{
	// Based on http://stackoverflow.com/questions/2526304/php-extract-gps-exif-data
	
	$result = array();
	
	if (!isset($exif['GPSLatitude'])) return array();
	if (!isset($exif['GPSLongitude'])) return array();
	
	// get the Hemisphere multiplier
	$LatM = 1; $LongM = 1;
	if($exif['GPSLatitudeRef'] == 'S')
	{
		$LatM = -1;
	}
	if($exif['GPSLongitudeRef'] == 'W')
	{
		$LongM = -1;
	}

	// get the GPS data
	$gps=array();
	if (!is_array($exif['GPSLatitude']))
	{
		$result['Latitude'] = $exif['GPSLatitude'];
		$result['Latitude'] = $exif['GPSLatitude'];
		return $result;
	}
	$gps['LatDegree']=$exif['GPSLatitude'][0];
	$gps['LatMinute']=$exif['GPSLatitude'][1];
	$gps['LatgSeconds']=isset($exif['GPSLatitude'][2])?$exif['GPSLatitude'][2]:0;
	$gps['LongDegree']=$exif['GPSLongitude'][0];
	$gps['LongMinute']=$exif['GPSLongitude'][1];
	$gps['LongSeconds']=isset($exif['GPSLongitude'][2])?$exif['GPSLongitude'][2]:0;

	// convert strings to numbers
	foreach($gps as $key => $value)
	{
		$pos = strpos($value, '/');
		if($pos !== false)
		{
			$temp = explode('/',$value);
			$gps[$key] = floatval($temp[0]) / floatval($temp[1]);
		}
	}

	// calculate the decimal degree
	$result['Latitude'] = float_to_raw_string($LatM * ($gps['LatDegree'] + ($gps['LatMinute'] / 60.0) + ($gps['LatgSeconds'] / 3600.0)));
	$result['Longitude'] = float_to_raw_string($LongM * ($gps['LongDegree'] + ($gps['LongMinute'] / 60.0) + ($gps['LongSeconds'] / 3600.0)));

	return $result;
}

/**
 * Attempt to retrieve a caption from photos seeking XMP, then EXIF, then IPTC binary last.
 * Check this file is a valid image file before passing to this function as an empty string often annoys.
 *
 * @param  string		This is the filename of the photo which may contain metadata
 * @return string		Whichever caption is found
 */
function _get_image_caption($path)
{
	$comments='';

	$file_pointer=fopen($path,'rb');

	if ($file_pointer!==false) //Attempt XMP
	{
		$file_cap100=fread($file_pointer,102400); //Read first 100k

		$x_start=strpos($file_cap100,'<x:xmpmeta');
		$x_end=strpos($file_cap100,'</x:xmpmeta');
		if (($x_start!==false) && ($x_end!==false))
			$file_cap=substr($file_cap100, $x_start, ($x_end+12)-$x_start);
		else
			$file_cap=substr($file_cap100, $x_start);

		if (isset($file_cap))
		{
			$get_result=array();

			preg_match('/<photoshop:Headline>(.*)<\/photoshop:Headline>/',$file_cap,$get_result); //Headline
			if (array_key_exists(1,$get_result))
				$comments=$get_result[1];
			else
			{
				preg_match('/<dc:title[^>]*>\s*<rdf:Alt[^>]*>\s*<rdf:li[^>]*>(.*)<\/rdf:li>\s*<\/rdf:Alt>\s*<\/dc:title>/',$file_cap,$get_result); //Title
				if (array_key_exists(1,$get_result))
					$comments=$get_result[1];
				else{
					preg_match('/<dc:description[^>]*>\s*<rdf:Alt[^>]*>\s*<rdf:li[^>]*>(.*)<\/rdf:li>\s*<\/rdf:Alt>\s*<\/dc:description>/',$file_cap,$get_result); //Description
					if (array_key_exists(1,$get_result))
						$comments=$get_result[1];
				}
			}
		}

		fclose($file_pointer);
	}
	if (($comments=='') && (function_exists('exif_read_data'))) //If XMP fails, attempt EXIF
	{
		$meta_data=@exif_read_data($path);

		$comments=isset($meta_data['ImageDescription'])?$meta_data['ImageDescription']:'';
		if ($comments=='')
		{
			$comments=isset($meta_data['Comments'])?$meta_data['Comments']:'';
		}
		if ($comments=='')
		{
			$comments=isset($meta_data['Title'])?$meta_data['Title']:'';
		}
		if ($comments=='')
		{
			$comments=isset($meta_data['COMPUTED']['UserComment'])?$meta_data['COMPUTED']['UserComment']:'';
		}
	}
	if ($comments=='') //IF XMP and EXIF fail, attempt IPTC binary
	{
		if (function_exists('getimagesize') && function_exists('iptcparse'))
		{
			$meta_data2=array();
			getimagesize($path,$meta_data2);
			if (isset($meta_data2['APP13']))
			{
				$meta_data2=iptcparse($meta_data2['APP13']);

				if (is_array($meta_data2))
				{
					if (array_key_exists('2#105',$meta_data2)) //Headline 256 bytes
					{
						if (array_key_exists(0,$meta_data2['2#105']))
							$comments=$meta_data2['2#105'][0];
					}
					elseif (array_key_exists('2#121',$meta_data2)) //Local-Caption 256 bytes
					{
						if (array_key_exists(0,$meta_data2['2#121']))
							$comments=$meta_data2['2#121'][0];
					}
					elseif (array_key_exists('2#120',$meta_data2)) //Caption-Abstract (AKA description) 2000 bytes
					{
						if (array_key_exists(0,$meta_data2['2#120']))
							$comments=$meta_data2['2#120'][0];
					}
				}
			}
		}
	}
	
	// Remove pointless camera names that some vendors put in
	if (strpos($comments,'SONY')!==false) $comments='';
	if (strpos($comments,'CANON')!==false) $comments='';
	if (strpos($comments,'NIKON')!==false) $comments='';
	if (strpos($comments,'OLYMPUS')!==false) $comments='';

	return $comments;
}
