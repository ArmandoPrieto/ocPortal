<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2014

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * Standard code module initialisation function.
 */
function init__sitemap()
{
	// Defining what should be gathered with the sitemap
	define('SITEMAP_GATHER_DESCRIPTION',1);
	define('SITEMAP_GATHER_IMAGE',2);
	define('SITEMAP_GATHER_DATES',4);
	define('SITEMAP_GATHER_SUBMITTER',8);
	define('SITEMAP_GATHER_VIEWS',16);
	define('SITEMAP_GATHER_RATING',32);
	define('SITEMAP_GATHER_META',64);
	define('SITEMAP_GATHER_CATEGORIES',128);
	define('SITEMAP_GATHER_DB_ROW',256);

	// Defining how the content-selection list should be put together
	define('NGC_PERMISSION_VIEW',1);
	define('NGC_PERMISSION_ADD',2);
	define('NGC_PERMISSION_EDIT',4);
	define('NGC_PERMISSION_DELETE',8);
}

/**
 * Find details of a position in the sitemap (shortcut into the object structure).
 *
 * @param  ?ID_TEXT 		The page-link we are finding (NULL: root).
 * @param  ?mixed  		Callback function to send discovered page-links to (NULL: return).
 * @param  ?array			List of node content types we will return/recurse-through (NULL: no limit)
 * @param  ?integer		How deep to go from the sitemap root (NULL: no limit).
 * @param  boolean		Only go so deep as needed to find nodes with permission-support (typically, stopping prior to the entry-level).
 * @param  ID_TEXT		The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
 * @param  boolean		Whether to filter out non-validated content.
 * @param  boolean		Whether to consider secondary categorisations for content that primarily exists elsewhere.
 * @param  integer		A bitmask of SITEMAP_GATHER_* constants, of extra data to include.
 * @return ?array			Result structure (NULL: working via callback).
 */
function retrieve_sitemap_node($pagelink=NULL,$callback=NULL,$valid_node_content_types=NULL,$max_recurse_depth=NULL,$require_permission_support=false,$zone='_SEARCH',$consider_validation=false,$consider_secondary_categories=false,$meta_gather=0)
{
	if (is_null($pagelink))
	{
		$hook='root';
		require_code('hooks/systems/sitemap/root');
		$ob=object_factory('Hook_sitemap_root');
	} else
	{
		$hook=mixed();
		$hooks=find_all_hooks('systems','sitemap');
		foreach (array_keys($hooks) as $_hook)
		{
			require_code('hooks/systems/sitemap/'.$_hook);
			$ob=object_factory('Hook_sitemap_'.$_hook);
			if ($ob->handles_pagelink($pagelink))
			{
				$hook=$_hook;
				break;
			}
		}
		if (is_null($hook))
			warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
	}

	return $ob->get_node($pagelink,$callback,$valid_node_content_types,$max_recurse_depth,0,$require_permission_support,$zone,$consider_secondary_categories,$consider_validation,$meta_gather);
}

/**
 * Get an HTML selection list for some part of the sitemap.
 *
 * @param  ID_TEXT  		The page-link we are starting from.
 * @param  ?ID_TEXT		Default selection (NULL: none).
 * @param  ?array			List of node content types we will return/recurse-through (NULL: no limit)
 * @param  ?array			List of node content types we will allow to be selectable (NULL: no limit)
 * @param  integer		Check permissions according to this bitmask of possibilities (requiring all in the bitmask to be matched)
 * @param  ?MEMBER		The member we are checking permissions for (NULL: current member)
 * @param  boolean		Whether to filter out non-validated entries if the $check_permissions_for user doesn't have the privilege to see them AND doesn't own them
 * @param  ?MEMBER		The member we are only finding owned content of (NULL: no such limit); nodes leading up to owned content will be shown, but not as selectable
 * @param  boolean		Whether to produce selection IDs as a comma-separated list of all selectable sub-nodes.
 * @param  ?mixed  		Filter function for limiting what rows will be included (NULL: none).
 * @return tempcode		List.
 */
function create_selection_list($root_pagelink,$default=NULL,$valid_node_content_types=NULL,$valid_selectable_content_types=NULL,$check_permissions_against=0,$check_permissions_for=NULL,$consider_validation=false,$only_owned=NULL,$use_compound_list=false,$filter_func=NULL)
{
	if (is_null($check_permissions_for)) $check_permissions_for=get_member();

	$out=new ocp_tempcode();
	$root_node=retrieve_sitemap_node($root_pagelink,NULL,NULL,false,'_SEARCH',$consider_validation,false,is_null($filter_func)?0:SITEMAP_GATHER_DB_ROW);
	foreach ($root_node['children'] as $child_node)
	{
		_create_selection_list($out,$child_node,$default,$valid_selectable_content_types,$check_permissions_against,$check_permissions_for,$only_owned,$use_compound_list,$filter_func);
	}
	return $out;
}

/**
 * Recurse function for create_selection_list.
 *
 * @param  tempcode  	Output Tempcode.
 * @param  array  		Node being recursed.
 * @param  ?ID_TEXT		Default selection (NULL: none).
 * @param  ?array			List of node content types we will allow to be selectable (NULL: no limit)
 * @param  integer		Check permissions according to this bitmask of possibilities (requiring all in the bitmask to be matched)
 * @param  ?MEMBER		The member we are checking permissions for (NULL: current member)
 * @param  ?MEMBER		The member we are only finding owned content of (NULL: no such limit); nodes leading up to owned content will be shown, but not as selectable
 * @param  boolean		Whether to produce selection IDs as a comma-separated list of all selectable sub-nodes.
 * @param  ?mixed  		Filter function for limiting what rows will be included (NULL: none).
 * @param  integer		Recursion depth.
 * @return string			Compound list.
 */
function _create_selection_list(&$out,$node,$default,$valid_selectable_content_types,$check_permissions_against,$check_permissions_for,$only_owned,$use_compound_list,$filter_func,$depth=0)
{
	// Skip?
	if (!is_null($check_permissions_for))
	{
		foreach ($node['permissions'] as $permission)
		{
			if (($check_permissions_against & NGC_PERMISSION_VIEW) != 0)
			{
				switch ($permission['type'])
				{
					case 'zone':
						if (!has_zone_access($check_permissions_for,$permission['zone_name']))
							return '';
						break;

					case 'page':
						if (!has_zone_access($check_permissions_for,$permission['zone_name'],$permission['page_name']))
							return '';
						break;

					case 'category':
						if (!has_category_access($check_permissions_for,$permission['permission_module'],$permission['category_name']))
							return '';
						break;
				}
			}
			if ($permission['type']=='privilege')
			{
				if (($check_permissions_against & NGC_PERMISSION_ADD) != 0)
				{
					if (preg_match('#^submit_#',$permission['privilege'])!=0)
					{
						if (!has_privilege($check_permissions_for,$permission['privilege'],$privilege['page_name'],array($privilege['permission_module'],$privilege['category_name'])))
							return '';
					}
				}
				if (($check_permissions_against & NGC_PERMISSION_EDIT) != 0)
				{
					if (preg_match('#^edit_#',$permission['privilege'])!=0)
					{
						if (!has_privilege($check_permissions_for,$permission['privilege'],$privilege['page_name'],array($privilege['permission_module'],$privilege['category_name'])))
							return '';
					}
				}
				if (($check_permissions_against & NGC_PERMISSION_DELETE) != 0)
				{
					if (preg_match('#^delete_#',$permission['privilege'])!=0)
					{
						if (!has_privilege($check_permissions_for,$permission['privilege'],$privilege['page_name'],array($privilege['permission_module'],$privilege['category_name'])))
							return '';
					}
				}
			}
		}
	}
	if (!is_null($only_owned))
	{
		if ($node['submitter']!=$only_owned) return '';
	}
	if (!is_null($filter_func))
	{
		if (!call_user_func($filter_func,$node)) return '';
	}

	// Recurse, working out $children and $compound_list
	$children=new ocp_tempcode();
	$child_compound_list='';
	foreach ($node['children'] as $node)
	{
		$_child_compound_list=_create_selection_list($children,$child_node,$default,$valid_selectable_content_types,$check_permissions_against,$check_permissions_for,$only_owned,$use_compound_list,$filter_func,$depth+1);
		if ($_child_compound_list!='')
			$child_compound_list.=($child_compound_list!='')?(','.$_child_compound_list):$_child_compound_list;
	}
	$compound_list=$content_id.(($child_compound_list!='')?(','.$child_compound_list):'');

	// Handle node
	$title=str_repeat(' ',$depth).$node['title'];
	$content_id=$node['content_id'];
	$selected=($content_id===is_integer($default)?strval($default):$default);
	$disabled=(!is_null($valid_selectable_content_types) && !in_array($node['content_type'],$valid_selectable_content_types));
	$_content_id=$use_compound_list?$compound_list:$content_id;
	$out->attach(form_input_list_entry($_content_id,$selected,$title,false,$disabled));

	// Attach recursion result
	$out->attach($children);

	return $compound_list;
}

abstract class Hook_sitemap_base
{
	/**
	 * Convert a page link to a category ID and category permission module type.
	 *
	 * @param  ID_TEXT		The page-link.
	 * @return boolean		Whether the page-link is handled by this hook.
	 */
	abstract function handles_pagelink($pagelink);

	/**
	 * Get a particular sitemap object. Used for easily tying in a different kind of child node.
	 *
	 * @param  ID_TEXT		The hook, i.e. the sitemap object type. Usually the same as a content type.
	 * @return object			The sitemap object.
	 */
	private function _get_sitemap_object($hook)
	{
		require_code('hooks/systems/sitemap/'.filter_naughty($hook));
		return object_factory('Hook_sitemap_'.$hook);
	}

	/**
	 * Find details of a position in the sitemap.
	 *
	 * @param  ID_TEXT  		The page-link we are finding.
	 * @param  ?string  		Callback function to send discovered page-links to (NULL: return).
	 * @param  ?array			List of node content types we will return/recurse-through (NULL: no limit)
	 * @param  ?integer		How deep to go from the sitemap root (NULL: no limit).
	 * @param  integer		Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by Google sitemap [deeper is typically less important]).
	 * @param  boolean		Only go so deep as needed to find nodes with permission-support (typically, stopping prior to the entry-level).
	 * @param  ID_TEXT		The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
	 * @param  boolean		Whether to filter out non-validated content.
	 * @param  boolean		Whether to consider secondary categorisations for content that primarily exists elsewhere.
	 * @param  integer		A bitmask of SITEMAP_GATHER_* constants, of extra data to include.
	 * @return ?array			Result structure (NULL: working via callback).
	 */
	abstract function get_node($pagelink,$callback=NULL,$valid_node_content_types=NULL,$max_recurse_depth=NULL,$recurse_level=0,$require_permission_support=false,$zone='_SEARCH',$consider_secondary_categories=false,$consider_validation=false,$meta_gather=0);

	/**
	 * Convert a page link to a category ID and category permission module type.
	 *
	 * @param  string	The page link
	 * @return ?array	The pair (NULL: permission modules not handled)
	 */
	abstract function extract_child_pagelink_permission_pair($pagelink);
}

abstract class Hook_sitemap_content extends Hook_sitemap_base
{
	abstract private $content_type;

	/**
	 * Convert a page link to a category ID and category permission module type.
	 *
	 * @param  ID_TEXT		The page-link.
	 * @return boolean		Whether the page-link is handled by this hook.
	 */
	function handles_pagelink($pagelink)
	{
		$matches=array();
		preg_match('#^([^:]*):([^:]*)#',$pagelink,$matches);
		$page=$matches[2];

		require_code('content');
		$ob=get_content_object($content_type);
		$info=$ob->info();
		return $info['module']==$page;
	}

	/**
	 * Convert a page link to a category ID and category permission module type.
	 *
	 * @param  string	The page link
	 * @return ?array	The pair (NULL: permission modules not handled)
	 */
	function extract_child_pagelink_permission_pair($pagelink)
	{
		$matches=array();
		preg_match('#^([^:]*):([^:]*):type=misc:id=(.*)$#',$pagelink,$matches);
		$id=$matches[3];

		require_code('content');
		$ob=get_content_object($content_type);
		$info=$ob->info();

		return array($id,$info['permissions_type_code']);
	}
}
