<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2011

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/*EXTRA FUNCTIONS: apache\_.+*/

/**
 * Standard code module initialisation function.
 */
function init__users()
{
	global $MEMBERS_BLOCKED,$MEMBERS_BLOCKING_US;
	$MEMBERS_BLOCKED=NULL;
	$MEMBERS_BLOCKING_US=NULL;
	global $SESSION_CACHE,$MEMBER_CACHED,$ADMIN_GROUP_CACHE,$MODERATOR_GROUP_CACHE,$USERGROUP_LIST_CACHE;
	global $USER_NAME_CACHE,$MEMBER_EMAIL_CACHE,$USERS_GROUPS_CACHE;
	global $SESSION_CONFIRMED,$GETTING_MEMBER,$EMOTICON_CACHE,$CACHED_THEME,$EMOTICON_LEVELS,$EMOTICON_SET_DIR;
	$EMOTICON_LEVELS=NULL;
	$USER_NAME_CACHE=array();
	$MEMBER_EMAIL_CACHE=array();
	$USERGROUP_LIST_CACHE=NULL;
	$USERS_GROUPS_CACHE=array();
	$ADMIN_GROUP_CACHE=NULL;
	$MODERATOR_GROUP_CACHE=NULL;
	$MEMBER_CACHED=NULL;
	$SESSION_CONFIRMED=0;
	$GETTING_MEMBER=false;
	$EMOTICON_CACHE=NULL;
	$CACHED_THEME=NULL;
	$EMOTICON_SET_DIR=NULL;
	global $IS_ACTUALLY_ADMIN;
	$IS_ACTUALLY_ADMIN=false;
	global $IS_A_COOKIE_LOGIN;
	$IS_A_COOKIE_LOGIN=false;

	global $IN_MINIKERNEL_VERSION;

	if (get_value('session_prudence')!=='1')
	{
		$SESSION_CACHE=persistant_cache_get('SESSION_CACHE');
	} else
	{
		$SESSION_CACHE=NULL;
	}
	if ((!is_array($SESSION_CACHE)) && ($IN_MINIKERNEL_VERSION==0))
	{
		if (get_value('session_prudence')!=='1')
		{
			$where='';
		} else
		{
			$where=' WHERE the_session='.strval(get_session_id()).' OR '.db_string_equal_to('ip',get_ip_address());
		}
		$SESSION_CACHE=array();
		if ((get_forum_type()=='ocf') && (get_db_site()==get_db_forums()) && (get_db_site_host()==get_db_forums_host()))
		{
			$GLOBALS['NO_DB_SCOPE_CHECK']=true;
			$_s=$GLOBALS['SITE_DB']->query('SELECT s.*,m.m_primary_group FROM '.get_table_prefix().'sessions s LEFT JOIN '.$GLOBALS['SITE_DB']->get_table_prefix().'f_members m ON m.id=s.the_user'.$where);
			$SESSION_CACHE=list_to_map('the_session',$_s);
			$GLOBALS['NO_DB_SCOPE_CHECK']=false;
		} else
		{
			$SESSION_CACHE=list_to_map('the_session',$GLOBALS['SITE_DB']->query('SELECT * FROM '.get_table_prefix().'sessions'.$where));
		}
		if (get_value('session_prudence')!=='1')
		{
			persistant_cache_set('SESSION_CACHE',$SESSION_CACHE);
		}
	}
}

/**
 * Get the value of a special 'ocp_' custom profile field.
 *
 * @param  ID_TEXT		The CPF name stem
 * @param  ?MEMBER		Member to lookup for (NULL: current member)
 * @return string			The value (blank: has a blank value, or does not exist)
 */
function get_ocp_cpf($cpf,$member=NULL)
{
	if (is_null($member)) $member=get_member();

	if (($cpf=='fullname') && (get_option('signup_fullname')=='1'))
	{
		return preg_replace('# \(\d+\)$#','',$GLOBALS['FORUM_DRIVER']->get_username($member));
	}

	$values=$GLOBALS['FORUM_DRIVER']->get_custom_fields($member);
	if (is_null($values)) return '';
	if (array_key_exists($cpf,$values)) return $values[$cpf];

	if (get_forum_type()=='ocf')
	{
		$values=ocf_get_all_custom_fields_match_member($member);
		if (array_key_exists($cpf,$values)) return $values[$cpf]['RAW'];
	}
	
	return '';
}

/**
 * Find whether the current member is logged in via httpauth.
 *
 * @return boolean		Whether the current member is logged in via httpauth
 */
function is_httpauth_login()
{
	if (get_forum_type()!='ocf') return false;
	if (is_guest()) return false;
	
	if (array_key_exists('REDIRECT_REMOTE_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['REDIRECT_REMOTE_USER']);
	if (array_key_exists('PHP_AUTH_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['PHP_AUTH_USER']);
	if (array_key_exists('REMOTE_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['REMOTE_USER']);

	/*if ($GLOBALS['FORUM_DRIVER']->get_member_row_field(get_member(),'m_password_compat_scheme')=='httpauth')
		return true;*/

	require_code('ocf_members');
	return ((array_key_exists('PHP_AUTH_USER',$_SERVER)) && (!is_null(ocf_authusername_is_bound_via_httpauth($_SERVER['PHP_AUTH_USER']))));
}

/**
 * Find whether the current member is a guest.
 *
 * @param  ?MEMBER		Member ID to check (NULL: current user)
 * @param  boolean		Whether to just do a quick check, don't establish new sessions
 * @return boolean		Whether the current member is a guest
 */
function is_guest($member_id=NULL,$quick_only=false)
{
	if ($member_id===NULL) $member_id=get_member($quick_only);
	return ($GLOBALS['FORUM_DRIVER']->get_guest_id()==$member_id);
}

/**
 * Apply hashing to some input. To this date, all forum drivers use md5, but some use it differently.
 * This function will pass through the parameters to an equivalent forum_md5 function if it is defined.
 *
 * @param  string			The data to hash (the password in actuality)
 * @param  string			The string converted member-ID in actuality, although this function is more general
 * @return string			The hashed data
 */
function my_md5($data,$key)
{
	if (method_exists($GLOBALS['FORUM_DRIVER'],'forum_md5')) return $GLOBALS['FORUM_DRIVER']->forum_md5($data,$key);
	return md5($data);
}

/**
 * Get database rows of all the online members.
 *
 * @param  boolean		Whether to use a longer online-time -- the session expiry-time
 * @param  ?MEMBER		We really only need to make sure we get the status for this user, although at this functions discretion more may be returned and the row won't be there if the user is not online (NULL: no filter). May not be the guest ID
 * @param  integer		The total online members, returned by reference
 * @return ?array			Database rows (NULL: too many)
 */
function get_online_members($longer_time,$filter,&$count)
{
	$users_online_time_seconds=$longer_time?(60*60*intval(get_option('session_expiry_time'))):(60*intval(get_option('users_online_time')));

	if (get_value('session_prudence')==='1')
	{
		// If we have multiple servers this many not be accurate as we probably turned replication off for the sessions table. The site design should be updated to not show this kind of info
		$count=$GLOBALS['SITE_DB']->query_value_null_ok_full('SELECT COUNT(*) FROM '.get_table_prefix().'sessions WHERE last_activity>'.strval($users_online_time_seconds));
		if (!is_null($filter))
			return $GLOBALS['SITE_DB']->query('SELECT * FROM '.get_table_prefix().'sessions WHERE last_activity>'.strval($users_online_time_seconds).' AND the_user='.strval($filter),1);
		return NULL;
	}
	
	$members=array();
	$cutoff=time()-$users_online_time_seconds;
	$guest_id=$GLOBALS['FORUM_DRIVER']->get_guest_id();
	global $SESSION_CACHE;
	$members_online=0;
	foreach ($SESSION_CACHE as $row)
	{
		if (!isset($row['the_user'])) continue; // Workaround to HipHop PHP weird bug

		if (($row['last_activity']>$cutoff) && ($row['session_invisible']==0))
		{
			if ($row['the_user']==$guest_id)
			{
				$count++;
				$members[]=$row;
				$members_online++;
				if ($members_online==200) // This is silly, don't display any
				{
					if (!is_null($filter)) // Unless we are filtering
						return $GLOBALS['SITE_DB']->query('SELECT * FROM '.get_table_prefix().'sessions WHERE last_activity>'.strval($users_online_time_seconds).' AND the_user='.strval($filter),1);
					return NULL;
				}
			} elseif (!member_blocked(get_member(),$row['the_user']))
			{
				$count++;
				$members[-$row['the_user']]=$row; // - (minus) is just a hackerish thing to allow it to do a unique, without messing with the above
			}
		}
	}
	return $members;
}

/**
 * Find if a member is online.
 *
 * @param  MEMBER			The member to check
 * @return boolean		Whether they are online
 */
function member_is_online($member_id)
{
	$count=0;
	$online=get_online_members(false,$member_id,$count);
	foreach ($online as $m)
	{
		if ($m['the_user']==$member_id) return true;
	}
	return false;
}

/**
 * Find if a member is blocked by a member.
 *
 * @param  MEMBER				The member being checked
 * @param  ?MEMBER			The member who may be blocking (NULL: current member)
 * @return boolean			Whether the member is blocked
 */
function member_blocked($member_id,$member_blocker=NULL)
{
	if (!addon_installed('chat')) return false;
	if (is_null($member_blocker)) $member_blocker=get_member();

	if ($member_blocker==$member_id) return false;
	if (is_guest($member_id)) return false;
	if (is_guest($member_blocker)) return false;

	if ($member_id==get_member())
	{
		global $MEMBERS_BLOCKING_US;
		if (is_null($MEMBERS_BLOCKING_US))
		{
			$rows=$GLOBALS['SITE_DB']->query_select('chat_blocking',array('member_blocker'),array('member_blocked'=>get_member()),'',NULL,NULL,true);
			if (is_null($rows))
			{
				$MEMBERS_BLOCKING_US=array();
				return false;
			}
			$MEMBERS_BLOCKING_US=collapse_1d_complexity('member_blocker',$rows);
		}
		return (in_array($member_blocker,$MEMBERS_BLOCKING_US));
	}

	global $MEMBERS_BLOCKED;
	if (is_null($MEMBERS_BLOCKED))
	{
		$rows=$GLOBALS['SITE_DB']->query_select('chat_blocking',array('member_blocked'),array('member_blocker'=>get_member()),'',NULL,NULL,true);
		if (is_null($rows))
		{
			$MEMBERS_BLOCKED=array();
			return false;
		}
		$MEMBERS_BLOCKED=collapse_1d_complexity('member_blocked',$rows);
	}
	return (in_array($member_id,$MEMBERS_BLOCKED));
}

/**
 * Handles an attempted login or logout, and take care of all the sessions and cookies etc.
 */
function handle_logins()
{
	if (get_param_integer('httpauth',0)==1)
	{
		require_code('users_inactive_occasionals');
		force_httpauth();
	}
	$username=trim(post_param('login_username',''));
	if (($username!='') && ($username!=do_lang('GUEST')))
	{
		require_code('users_active_actions');
		handle_active_login($username);
	}

	// If it was a log out
	$page=get_page_name();
	$type=get_param('type','',true);
	if (($page=='login') && ($type=='logout'))
	{
		require_code('users_active_actions');
		handle_active_logout();
	}
}

/**
 * Get the ID of the currently active member.
 * It see's if the session exists / cookie is valid -- and gets the member id accordingly
 *
 * @param  boolean		Whether to just do a quick check, don't establish new sessions
 * @return MEMBER			The member requesting this web page (possibly the guest member - which strictly speaking, is not a member)
 */
function get_member($quick_only=false)
{
	global $SESSION_CACHE,$MEMBER_CACHED,$GETTING_MEMBER,$SITE_INFO;

	if ($MEMBER_CACHED!==NULL)
	{
		$GETTING_MEMBER=false;
		return $MEMBER_CACHED;
	}

	reset($SESSION_CACHE);
	if ((count($SESSION_CACHE)>50) && ($SESSION_CACHE[key($SESSION_CACHE)]['last_activity']<time()-60*60*max(1,intval(get_option('session_expiry_time')))))
		delete_expired_sessions();

	$backdoor_ip_address=mixed(); // Enable to a real IP address to force login from FTP access (if lost admin password)
	if (array_key_exists('backdoor_ip',$SITE_INFO)) $backdoor_ip_address=$SITE_INFO['backdoor_ip'];
	if ((is_string($backdoor_ip_address)) && (get_ip_address()==$backdoor_ip_address))
	{
		require_code('users_active_actions');
		$MEMBER_CACHED=restricted_manually_enabled_backdoor();
		return $MEMBER_CACHED;
	}

	if ($GETTING_MEMBER)
	{
		return $GLOBALS['FORUM_DRIVER']->get_guest_id();
	}
	$GETTING_MEMBER=true;

	global $FORCE_INVISIBLE_GUEST;
	if ($FORCE_INVISIBLE_GUEST)
	{
		$GETTING_MEMBER=false;
		$MEMBER_CACHED=$GLOBALS['FORUM_DRIVER']->get_guest_id();
		return $MEMBER_CACHED;
	}

	$member=NULL;

	$cookie_bits=explode(':',str_replace('|',':',get_member_cookie()));
	$base=$cookie_bits[0];

	// Try by session
	$session=get_session_id();
	if (($session!=-1) && (get_param_integer('keep_force_htaccess',0)==0))
	{
		$ip=get_ip_address(3); // I hope AOL can cope with this
		$allow_unbound_guest=true; // Note: Guest sessions are not IP bound
		$member_row=NULL;

		if (($SESSION_CACHE!==NULL) && (array_key_exists($session,$SESSION_CACHE)) && ($SESSION_CACHE[$session]!==NULL) && (array_key_exists('the_user',$SESSION_CACHE[$session])) && ((get_option('ip_strict_for_sessions')=='0') || ($SESSION_CACHE[$session]['ip']==$ip) || ((is_guest($SESSION_CACHE[$session]['the_user'])) && ($allow_unbound_guest)) || (($SESSION_CACHE[$session]['session_confirmed']==0) && (!is_guest($SESSION_CACHE[$session]['the_user'])))) && ($SESSION_CACHE[$session]['last_activity']>time()-60*60*max(1,intval(get_option('session_expiry_time')))))
			$member_row=$SESSION_CACHE[$session];
		if (($member_row!==NULL) && ((!array_key_exists($base,$_COOKIE)) || (!is_guest($member_row['the_user']))))
		{
			$member=$member_row['the_user'];

			if (($member!==NULL) && ((time()-$member_row['last_activity'])>10)) // Performance optimisation. Pointless re-storing the last_activity if less than 3 seconds have passed!
			{
				//$GLOBALS['SITE_DB']->query_update('sessions',array('last_activity'=>time(),'the_zone'=>get_zone_name(),'the_page'=>get_page_name()),array('the_session'=>$session),'',1);  Done in get_page_title now
				$SESSION_CACHE[$session]['last_activity']=time();
				if (get_value('session_prudence')!=='1')
				{
					persistant_cache_set('SESSION_CACHE',$SESSION_CACHE);
				}
			}
			global $SESSION_CONFIRMED;
			$SESSION_CONFIRMED=$member_row['session_confirmed'];

			if (get_forum_type()=='ocf') $GLOBALS['FORUM_DRIVER']->ocf_flood_control($member);

			if ((!is_guest($member)) && ($GLOBALS['FORUM_DRIVER']->is_banned($member))) // All hands to the guns
			{
				warn_exit(do_lang_tempcode('USER_BANNED'));
			}

			// Test this member still exists
			if ($GLOBALS['FORUM_DRIVER']->get_username($member)===NULL) $member=$GLOBALS['FORUM_DRIVER']->get_guest_id();

			if (array_key_exists($base,$_COOKIE))
			{
				global $IS_A_COOKIE_LOGIN;
				$IS_A_COOKIE_LOGIN=true;
			}
		} else
		{
			require_code('users_inactive_occasionals');
			set_session_id(-1);
			$session=-1;
		}
	}

	if (($session==-1) && (get_param_integer('keep_force_htaccess',0)==0) && ($member===NULL))
	{
		// Try by cookie
		require_code('users_inactive_occasionals');
		$member=cookie_login();

		// Can forum driver help?
		if (method_exists($GLOBALS['FORUM_DRIVER'],'get_member')) $member=$GLOBALS['FORUM_DRIVER']->get_member();
	}

	// Can we try to see if we're httpauth-bound instead?
	// Security note...
	// New httpauth users will be added as members. Don't edit this to make them be added as privileged members, because presence of PHP_AUTH_USER only guarantees an authentication if it passed though an appropriate .htaccess (which would have filtered bad authentications for us). We are ASSUMING here that this is the case and therefore this must not be a permissive thing (all useful modules should also be in a .htaccess or privilege protected zone to stop member spoofing)
	// As an alternative to the above, we will not allow httpauth to the welcome zone, as by convention, this is a place for visitors. If using httpauth, all other zones should have a relevant .htaccess.
	// We could store the password from the first login and authenticate against that: but we do not want to create a sync issue.
	// So to summarise, either:
	//  - Don't assign any special permissions to these kinds of members
	//  - or, lock off all zones with .htaccess other than root (and root has httpauth login denied)

	if (array_key_exists('REDIRECT_REMOTE_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['REDIRECT_REMOTE_USER']);
	
	if (array_key_exists('PHP_AUTH_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['PHP_AUTH_USER']);

	if (array_key_exists('REMOTE_USER',$_SERVER))
		$_SERVER['PHP_AUTH_USER']=preg_replace('#@.*$#','',$_SERVER['REMOTE_USER']);

	if (get_value('ntlm')==='1') // Taken from http://www.wascou.org/wascou/Blogs/Xavier-GOULEY/Alternate-way-to-Kerberos-NTLM-auth-in-pure-PHP
	{
		$headers = apache_request_headers();
		if(!isset($headers['Authorization'])) // step 1
		{
			header( "HTTP/1.1 401 Unauthorized" ); // step 2
			header( "WWW-Authenticate: NTLM" );
			exit();
		}
		if(isset($headers['Authorization']) && substr($headers['Authorization'],0,5) == 'NTLM ')
		{
			// step 3 to 6
			$chaine=$headers['Authorization'];
			$chaine=substr($chaine, 5); // type1 message
			$chained64=base64_decode($chaine);
			if(ord($chained64[8]) == 1) // step 3
			{
				// check NTLM flag "0xb2",
				// offset 13 in type-1-message :
				if (ord($chained64[13]) != 178)
				{
					warn_exit("Please use NTLM compatible browser");
				}
				$ret_auth = "NTLMSSP";
				$ret_auth .= chr(0).chr(2).chr(0).chr(0);
				$ret_auth .= chr(0).chr(0).chr(0).chr(0);
				$ret_auth .= chr(0).chr(40).chr(0).chr(0);
				$ret_auth .= chr(0).chr(1).chr(130).chr(0);
				$ret_auth .= chr(0).chr(0).chr(2).chr(2);
				$ret_auth .= chr(2).chr(0).chr(0).chr(0);
				$ret_auth .= chr(0).chr(0).chr(0).chr(0);
				$ret_auth .= chr(0).chr(0).chr(0).chr(0).chr(0);

				$ret_auth64 =base64_encode($ret_auth);
				$ret_auth64 = trim($ret_auth64);
				header( "HTTP/1.1 401 Unauthorized" ); // step 4
				header( "WWW-Authenticate: NTLM $ret_auth64" );
				exit();
			}
			elseif(ord($chained64[8]) == 3) // step 5
			{
				$lenght_domain = (ord($chained64[31])*256 + ord($chained64[30]));
				$offset_domain = (ord($chained64[33])*256 + ord($chained64[32]));
				$domain = substr($chained64, $offset_domain, $lenght_domain);
				$lenght_login = (ord($chained64[39])*256 + ord($chained64[38]));
				$offset_login = (ord($chained64[41])*256 + ord($chained64[40]));
				$login = substr($chained64, $offset_login, $lenght_login);
				$lenght_host = (ord($chained64[47])*256 + ord($chained64[46]));
				$offset_host = (ord($chained64[49])*256 + ord($chained64[48]));
				$host = substr($chained64, $offset_host, $lenght_host);
			}
		}
		$_SERVER['PHP_AUTH_USER']=strtolower(preg_replace("/(.)(.)/","$1",$login));
	} else
	{
		if (get_option('windows_auth_is_enabled',true)=='1' && ((!array_key_exists('PHP_AUTH_USER',$_SERVER) || $_SERVER['PHP_AUTH_USER']=='')))
		{
			// For Windows auth, we force this always. For httpauth on non-Windows we let the .htaccess file force this, if the webmaster wants it
			header('HTTP/1.1 401 Unauthorized');
			header('WWW-Authenticate: Negotiate');
			header('WWW-Authenticate: Basic',false);
			exit();
		}

		if ((get_value('force_admin_auth')==='1') && ($GLOBALS['FORUM_DRIVER']->is_super_admin($GLOBALS['FORUM_DRIVER']->get_member_from_username($_SERVER['PHP_AUTH_USER']))))
		{
			$headers = apache_request_headers();
			if (!isset($headers['Authorization']))
			{
				header('Location: '.get_base_url().'admin_login/index.php');
				exit();
			}
		}
	}

	if ((array_key_exists('PHP_AUTH_USER',$_SERVER)) && (($member===NULL) || (is_guest($member))) && ((get_option('httpauth_is_enabled',true)=='1') || (get_option('windows_auth_is_enabled',true)=='1')) && (get_forum_type()=='ocf'))
	{	
		require_code('users_inactive_occasionals');
		$member=httpauth_login();		
	}

	// Guest or banned
	if ($member===NULL)
	{
		$member=$GLOBALS['FORUM_DRIVER']->get_guest_id();
		$is_guest=true;
	} else
	{
		$is_guest=($member==$GLOBALS['FORUM_DRIVER']->get_guest_id());
	}

	// Ensure there is a session, if we aren't trying to bomb out with a page cache quick
	global $SITE_INFO;
	if ($quick_only)
	{
		$GETTING_MEMBER=false;
		return $member;
	}
	$session=get_session_id();
	if ($session==-1)
	{
		require_code('users_inactive_occasionals');
		create_session($member);
	}

	if (!$is_guest)
	{
		// Is there a su operation?
		$ks=get_param('keep_su','');
		if ($ks!='')
		{
			require_code('users_inactive_occasionals');
			$member=su_login($member);
		}

		// Run hooks, if any exist
		$hooks=find_all_hooks('systems','upon_login');
		foreach (array_keys($hooks) as $hook)
		{
			require_code('hooks/systems/upon_login/'.filter_naughty($hook));
			$ob=object_factory('upon_login'.filter_naughty($hook),true);
			if ($ob===NULL) continue;
			$ob->run(false,NULL,$member); // false means "not a new login attempt"
		}
	}

	// Ok we have our answer
	$MEMBER_CACHED=$member;
	$GETTING_MEMBER=false;
	return $member;
}

/**
 * Find what sessions are expired and delete them.
 *
 * @param  ?MEMBER		User to get a current session for (NULL: do not try, which guarantees a return result of NULL also) 
 * @return ?AUTO_LINK	The session id we rebound to (NULL: did not rebind)
 */
function delete_expired_sessions($id=NULL)
{
	$new_session=NULL;
	
	// Delete expired sessions
	$GLOBALS['SITE_DB']->query('DELETE FROM '.get_table_prefix().'sessions WHERE last_activity<'.strval(time()-60*60*max(1,intval(get_option('session_expiry_time')))));
	$new_session=NULL;
	$dirty_session_cache=false;
	global $SESSION_CACHE;
	foreach ($SESSION_CACHE as $_session=>$row)
	{
		if (!array_key_exists('the_user',$row)) continue; // Workaround to HipHop PHP weird bug

		// Delete expiry from cache
		if ($row['last_activity']<time()-60*60*max(1,intval(get_option('session_expiry_time'))))
		{
			$dirty_session_cache=true;
			unset($SESSION_CACHE[$_session]);
			continue;
		}

		// Get back to prior session if there was one
		if (get_value('allowed_shared_usernames')!=='1')
		{
			if (($id!==NULL) && ($row['the_user']==$id))
			{
				$new_session=$_session;
			}
		}
	}
	if ($dirty_session_cache)
	{
		if (get_value('session_prudence')!=='1')
		{
			persistant_cache_set('SESSION_CACHE',$SESSION_CACHE);
		}
	}
	
	return $new_session;
}

/**
 * Get the member cookie's name.
 *
 * @return string			The member username/id (depending on forum driver) cookie's name
 */
function get_member_cookie()
{
	global $SITE_INFO;
	if (!array_key_exists('user_cookie',$SITE_INFO)) $SITE_INFO['user_cookie']='ocp_member_id';
	return $SITE_INFO['user_cookie'];
}

/**
 * Get the member password cookie's name.
 *
 * @return string			The member password cookie's name
 */
function get_pass_cookie()
{
	global $SITE_INFO;
	if (!array_key_exists('pass_cookie',$SITE_INFO)) $SITE_INFO['pass_cookie']='ocp_member_hash';
	return $SITE_INFO['pass_cookie'];
}

/**
 * Get the current session ID.
 *
 * @return integer		The current session ID
 */
function get_session_id()
{
	if ((!isset($_COOKIE['ocp_session'])) || (/*To work around OcCLE's development mode trick*/$GLOBALS['DEBUG_MODE'] && running_script('occle')))
	{
		if (array_key_exists('keep_session',$_GET)) return get_param_integer('keep_session');
		return (-1);
	}
	return intval($_COOKIE['ocp_session']); // No need to stripslashes as it's numeric
}

/**
 * Make sure that the given URL contains a session if cookies are disabled.
 * NB: This is used for login redirection. It had to add the session id into the redirect url.
 *
 * @param  URLPATH		The URL to enforce results in session persistence for the user
 * @return URLPATH		The fixed URL (potentially nothing was done, depending on cookies)
 */
function enforce_sessioned_url($url)
{
	if ((!has_cookies()) && (is_null(get_bot_type())))
	{
		require_code('users_inactive_occasionals');
		return _enforce_sessioned_url($url);
	}
	return $url;
}

/**
 * Get a cookie value.
 *
 * @param  string			The name of the cookie
 * @param  ?string		The default value (NULL: just use the value NULL)
 * @return ?string		The value stored in the cookie (NULL: the default default)
 */
function ocp_admirecookie($name,$default=NULL)
{
	if (!isset($_COOKIE[$name])) return $default;
	$the_cookie=$_COOKIE[$name];
	if (get_magic_quotes_gpc()) $the_cookie=stripslashes($the_cookie);
	return $the_cookie;
}

/**
 * Deletes a cookie (if it exists), from within ocPortal's cookie environment.
 *
 * @param  string			The name of the cookie
 * @return boolean		The result of the PHP setcookie command
 */
function ocp_eatcookie($name)
{
	$expire=time()-100000; // Note the negative number must be greater than 13*60*60 to account for maximum timezone difference

	// Try and remove other potentials
	@setcookie($name,'',$expire,'',preg_replace('#^www\.#','',ocp_srv('HTTP_HOST')));
	@setcookie($name,'',$expire,'/',preg_replace('#^www\.#','',ocp_srv('HTTP_HOST')));
	@setcookie($name,'',$expire,'','www.'.preg_replace('#^www\.#','',ocp_srv('HTTP_HOST')));
	@setcookie($name,'',$expire,'/','www.'.preg_replace('#^www\.#','',ocp_srv('HTTP_HOST')));
	@setcookie($name,'',$expire,'','');
	@setcookie($name,'',$expire,'/','');

	// Delete standard potential
	return @setcookie($name,'',$expire,get_cookie_path(),get_cookie_domain());
}
