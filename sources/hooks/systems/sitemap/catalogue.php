<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2014

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		catalogues
 */

class Hook_sitemap_catalogue extends Hook_sitemap_content
{
	protected $content_type='catalogue';
	protected $screen_type='index';

	// If we have a different content type of entries, under this content type
	protected $entry_content_type=array('catalogue_category');
	protected $entry_sitetree_hook=array('catalogue_category');

	/**
	 * Get the permission page that nodes matching $pagelink in this hook are tied to.
	 * The permission page is where privileges may be overridden against.
	 *
	 * @param  string			The page-link
	 * @return ?ID_TEXT		The permission page (NULL: none)
	 */
	function get_permission_page($pagelink)
	{
		return 'cms_catalogues';
	}

	/**
	 * Find details of a virtual position in the sitemap. Virtual positions have no structure of their own, but can find child structures to be absorbed down the tree. We do this for modularity reasons.
	 *
	 * @param  ID_TEXT  		The page-link we are finding.
	 * @param  ?string  		Callback function to send discovered page-links to (NULL: return).
	 * @param  ?array			List of node types we will return/recurse-through (NULL: no limit)
	 * @param  ?integer		How deep to go from the sitemap root (NULL: no limit).
	 * @param  integer		Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by Google sitemap [deeper is typically less important]).
	 * @param  boolean		Only go so deep as needed to find nodes with permission-support (typically, stopping prior to the entry-level).
	 * @param  ID_TEXT		The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
	 * @param  boolean		Whether to filter out non-validated content.
	 * @param  boolean		Whether to consider secondary categorisations for content that primarily exists elsewhere.
	 * @param  integer		A bitmask of SITEMAP_GATHER_* constants, of extra data to include.
	 * @param  ?array			Database row (NULL: lookup).
	 * @return ?array			List of node structures (NULL: working via callback).
	 */
	function get_virtual_nodes($pagelink,$callback=NULL,$valid_node_types=NULL,$max_recurse_depth=NULL,$recurse_level=0,$require_permission_support=false,$zone='_SEARCH',$consider_secondary_categories=false,$consider_validation=false,$meta_gather=0,$row=NULL)
	{
		$nodes=($callback===NULL)?array():mixed();

		if (($valid_node_types!==NULL) && (!in_array($this->content_type,$valid_node_types)))
		{
			return $nodes;
		}

		if ($require_permission_support)
		{
			return $nodes;
		}

		$start=0;
		do
		{
			$rows=$GLOBALS['SITE_DB']->query_select('catalogues',array('*'),NULL,'',SITEMAP_MAX_ROWS_PER_LOOP,$start);
			foreach ($rows as $row)
			{
				if (substr($row['c_name'],0,1)!='_')
				{
					// Index
					$child_pagelink=$zone.':catalogues:index:'.$row['c_name'];
					$node=$this->get_node($child_pagelink,$callback,$valid_node_types,$max_recurse_depth,$recurse_level,$require_permission_support,$zone,$consider_secondary_categories,$consider_validation,$meta_gather,$row);
					if ($callback===NULL) $nodes[]=$node;

					// A-to-Z
					$child_pagelink=$zone.':catalogues:atoz:'.$row['c_name'];
					$node=$this->get_node($child_pagelink,$callback,$valid_node_types,$max_recurse_depth,$recurse_level,$require_permission_support,$zone,$consider_secondary_categories,$consider_validation,$meta_gather,$row);
					if ($callback===NULL) $nodes[]=$node;

					// Categories
					$lots=($GLOBALS['SITE_DB']->query_select_value_if_there('catalogue_categories','COUNT(*)',array('c_name'=>$row['c_name']))>1000) && (db_has_subqueries($GLOBALS['SITE_DB']->connection_read));
					if (!$lots)
					{
						$children=$this->_get_children_nodes($content_id,$pagelink,$callback,$valid_node_types,$max_recurse_depth,$recurse_level,$require_permission_support,$zone,$consider_secondary_categories,$consider_validation,$meta_gather,$row);
						if ($callback===NULL) $nodes=array_merge($nodes,$children);
					}
				}
			}

			$start+=SITEMAP_MAX_ROWS_PER_LOOP;
		}
		while (count($rows)>0);

		return $nodes;
	}

	/**
	 * Find details of a position in the Sitemap.
	 *
	 * @param  ID_TEXT  		The page-link we are finding.
	 * @param  ?string  		Callback function to send discovered page-links to (NULL: return).
	 * @param  ?array			List of node types we will return/recurse-through (NULL: no limit)
	 * @param  ?integer		How deep to go from the Sitemap root (NULL: no limit).
	 * @param  integer		Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by XML Sitemap [deeper is typically less important]).
	 * @param  boolean		Only go so deep as needed to find nodes with permission-support (typically, stopping prior to the entry-level).
	 * @param  ID_TEXT		The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
	 * @param  boolean		Whether to filter out non-validated content.
	 * @param  boolean		Whether to consider secondary categorisations for content that primarily exists elsewhere.
	 * @param  integer		A bitmask of SITEMAP_GATHER_* constants, of extra data to include.
	 * @param  ?array			Database row (NULL: lookup).
	 * @return ?array			Node structure (NULL: working via callback / error).
	 */
	function get_node($pagelink,$callback=NULL,$valid_node_types=NULL,$max_recurse_depth=NULL,$recurse_level=0,$require_permission_support=false,$zone='_SEARCH',$consider_secondary_categories=false,$consider_validation=false,$meta_gather=0,$row=NULL)
	{
		$_=$this->_create_partial_node_structure($pagelink,$callback,$valid_node_types,$max_recurse_depth,$recurse_level,$require_permission_support,$zone,$consider_secondary_categories,$consider_validation,$meta_gather,$row);
		if ($_===NULL) return NULL;
		list($content_id,$row,$partial_struct)=$_;

		$struct=array(
			'sitemap_priority'=>SITEMAP_IMPORTANCE_MEDIUM,
			'sitemap_refreshfreq'=>'weekly',

			'permission_page'=>$this->get_permission_page($pagelink),
		)+$partial_struct;

		if (strpos($pagelink,':atoz:')!==false)
		{
			$test=find_theme_image('icons/24x24/menu/rich_content/atoz',true);
			if ($test!='')
				$struct['image']=$test;
			$test=find_theme_image('icons/48x48/menu/rich_content/atoz',true);
			if ($test!='')
				$struct['image_2x']=$test;
		} else
		{
			$test=find_theme_image('icons/24x24/menu/rich_content/catalogues/'.$content_id,true);
			if ($test!='')
				$struct['image']=$test;
			$test=find_theme_image('icons/48x48/menu/rich_content/catalogues/'.$content_id,true);
			if ($test!='')
				$struct['image_2x']=$test;
		}

		if ($callback!==NULL)
			call_user_func($callback,$struct);

		return ($callback===NULL)?$struct:NULL;
	}
}
