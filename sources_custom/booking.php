<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2011

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		booking
 */

/*
Much of this API works via booking details structure, which is an array consisting of...

bookable_id
start_day/month/year
end day/month/year
quantity
supplements
 quantity
 notes

The definition of booking here is user-focused, the user is making a booking for a period, ordering a number of bookables.

These are saved into the database under a different definition of 'booking', where bookings are actually very specific.

One user booking becomes a lot of separate bookings for separate things when it comes to the database.
*/

/**
 * Standard code module init function.
 */
function init_booking()
{
	// TODO: Make these into options
	define('SHOW_WARNINGS_UNTIL',time()+60*60*24*31*6); // 6 months
	define('MAX_AHEAD_BOOKING_DATE',time()+60*60*24*365*3); // 3 years
}

/**
 * Generate a new set of booking codes.
 *
 * @param  integer	How many codes to generate.
 * @return array		The generated codes.
 */
function generate_random_booking_codes($num)
{
	$codes=array();
	while (count($codes)<$num)
	{
		$codes[substr(md5(uniqid('ocp_booking_',true)),0,5)]=1;
	}
	return array_keys($codes);
}

/**
 * See if a booking is possible.
 *
 * @param  array		Booking details structure to check, passed by reference as statuses get added.
 * @return ?tempcode	Error message (NULL: no issue).
 */
function check_booking_dates_available(&$request)
{
	$success=mixed();
	foreach ($request as $i=>$part)
	{
		foreach (days_in_range($part['start_day'],$part['start_month'],$part['start_year'],$part['end_day'],$part['end_month'],$part['end_year']) as $_date)
		{
			list($day,$month,$year)=$_date;
			$status_error=booking_date_available($part['bookable_id'],$day,$month,$year,$part['quantity']);
			$part['status_error']=$status_error;
			if ((!is_null($available)) && (is_null($success)))
			{
				$success=$available; // Set status to first error
			}
		}
		$request[$i]=$part;
	}
	return $success;
}

/**
 * Read in notes from POST environment, using special naming conventions.
 *
 * @param  string		The prefix for defining what to read in.
 * @return string		The notes.
 */
function read_booking_notes_from_form($prefix)
{
	// Read in notes. We have a special post parameter syntax for defining structured notes (custom fields on the form), so that we can allow webmasters to take some rich input
	$notes=post_param($prefix,'');
	$prefix.='_';
	foreach (array_keys($_POST) as $post)
	{
		if (substr($post,0,strlen($prefix))==$prefix)
		{
			if ($notes!='') $notes.=chr(10).chr(10);
			$notes.=post_param('descript_'.$post,$post).':'.chr(10).post_param($post,'');
		}
	}
	return $notes;
}

/**
 * Read booking request from POST environment.
 *
 * @return array		Booking details structure.
 */
function get_booking_request_from_form()
{
	$request=array();

	$bookables=collapse_1d_complexity('id',$GLOBALS['SITE_DB']->query_select('bookable',array('id')));
	foreach ($bookables as $bookable_id)
	{
		$all_supplements=$GLOBALS['SITE_DB']->query_select('bookable_supplement',array('*'));

		$quantity=post_param_integer('booking_quantity_'.strval($bookable_id),0);
		if ($quantity>0)
		{
			$start=get_input_date('booking_'.strval($bookable_id).'_date_from');
			$start_day=intval('d',$start);
			$start_month=intval('m',$start);
			$start_year=intval('Y',$start);
			if ($bookable['dates_are_ranges']==1)
			{
				$end=get_input_date('booking_'.strval($bookable_id).'_date_to');
				$end_day=intval('d',$end);
				$end_month=intval('m',$end);
				$end_year=intval('Y',$end);
			} else
			{
				$end_day=$start_day;
				$end_month=$start_month;
				$end_year=$start_year;
			}

			$notes=read_booking_notes_from_form('booking_'.strval($bookable_id).'_notes');

			$supplements=array();
			foreach ($all_supplements as $supplement)
			{
				$quantity=post_param_integer('supplement_'.strval($supplement['id']).'_quantity',0);
				if ($quantity>0)
				{
					$notes=read_booking_notes_from_form('supplement_'.strval($bookable_id).'_'.strval($supplement['id']).'_notes');

					$supplements[$supplement['id']]=array(
						'quantity'=>$quantity,
						'notes'=>$notes,
					);
				}
			}

			$request[]=array('bookable_id'=>$bookable_id,'start_day'=>$start_day,'start_month'=>$start_month,'start_year'=>$start_year,'end_day'=>$end_day,'end_month'=>$end_month,'end_year'=>$end_year,'quantity'=>$quantity,'notes'=>$notes,'supplements'=>$supplements);
		}
	}

	return $request;
}

/**
 * Take details posted about a booking, and save to the database.
 *
 * @param  array		Booking details structure.
 * @param  ?MEMBER	The member ID we are saving as (NULL: current user).
 * @return ?array		Booking details structure (NULL: error -- reshow form).
 */
function save_booking_form_to_db($request,$member_id=NULL)
{
	if (is_null($member_id)) $member_id=get_member();

	if (is_guest($member_id)) fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));

	$test=check_booking_dates_available($request);
	if (!is_null($test))
	{
		attach_message($test,'warn');
		return NULL;
	}

	add_booking($request);

	return $request;
}

/**
 * Add a new booking to the database.
 *
 * @param  ?array		Booking details structure.
 */
function add_booking($request)
{
	foreach ($request as $rid=>$req)
	{
		$days=days_in_range($req['start_day'],$req['start_month'],$req['start_year'],$req['end_day'],$req['end_month'],$req['end_year']);

		// Now insert into DB. Technically each day gets its own booking
		for ($i=0;$i<$req['quantity'];$i++)
		{
			$code=mixed();

			foreach ($days as $j=>$_date)
			{
				list($day,$month,$year)=$_date;

				$code=find_free_bookable_code($req['bookable_id'],$day,$month,$year,$code); // Hopefully $code will stay the same, but it might not
				if (is_null($code)) fatal_exit(do_lang_tempcode('INTERNAL_ERROR')); // Should not be possible, as we already checked availability

				$booking_id=$GLOBALS['SITE_DB']->query_insert('booking',array(
					'member_id'=>$member_id,
					'day'=>$day,
					'month'=>$month,
					'year'=>$year,
					'code_allocation'=>$code,
					'notes'=>$notes,
					'booked_at'=>time(),
					'paid_at'=>NULL,
					'paid_trans_id'=>NULL,
				),true);

				// Supplements
				foreach ($req['supplements'] as $supplement)
				{
					$GLOBALS['SITE_DB']->query_insert('booking_supplement',array(
						'booking_id'=>$booking_id,
						'supplement_id'=>$supplement['id'],
						'quantity'=>$supplement['quantity'],
						'notes'=>$supplement['notes'],
					));
				}
			}
		}
	}
}

/**
 * Find an available code for a booking for the bookable on a given date.
 *
 * @param  AUTO_LINK	Bookable ID.
 * @param  integer	Day.
 * @param  integer	Month.
 * @param  integer	Year.
 * @param  ID_TEXT	Preferred code (often passed in as the last code provided, in order to provide continuity to guests).
 * @return ?ID_TEXT	The code (NULL: could not find a code).
 */
function find_free_bookable_code($bookable_id,$day,$month,$year,$preferred_code)
{
	$_available=$GLOBALS['SITE_DB']->query_select('bookable_codes a LEFT JOIN '.get_table_prefix().'booking b ON a.bookable_id=b.bookable_id AND b.day='.strval($day).' AND b.month='.strval($month).' AND b.year='.strval($year),array('b.id'=>NULL,'a.bookable_id'=>$bookable_id));
	$available=collapse_1d_complexity('code',$_available);
	if (in_array($preferred_code,$available)) return $preferred_code;
	if (!array_key_exists(0,$available)) return NULL;
	return $available[0];
}

/**
 * Find the price for a booking. This may involve multiple bookables, as at this point we don't care about that or not (once in the DB, it will actually be considered many separate bookings)
 *
 * @param  array		Booking details structure to check.
 * @return REAL		The price.
 */
function find_booking_price($request)
{
	$price=0.0;

	foreach ($request as $i=>$part)
	{
		$days=days_in_range($part['start_day'],$part['start_month'],$part['start_year'],$part['end_day'],$part['end_month'],$part['end_year']);
		foreach ($days as $_date)
		{
			$price+=find_bookable_price($part['bookable_id'])*$part['quantity'];
		}

		foreach ($part['supplements'] as $supplement_id=>$supplement_part)
		{
			$supplement_quantity=$supplement_part['quantity'];

			$_supplement=$GLOBALS['SITE_DB']->query_select('bookable_supplement',array('*'),array('id'=>$supplement_id),'',1);
			if (array_key_exists(0,$_supplement))
			{
				$price+=$_supplement[0]['price']*$supplement_quantity*(($_supplement[0]['price_is_per_period']==1)?count($days):1);

				if (($supplement_quantity!=0) && ($_supplement[0]['supports_quantities']==0)) fatal_exit('INTERNAL_ERROR');
			}
		}
	}

	return $price;
}

/**
 * Find the price of a bookable.
 *
 * @param  AUTO_LINK	Bookable ID.
 * @return REAL		Price.
 */
function find_bookable_price($bookable_id)
{
	return $GLOBALS['SITE_DB']->query_value('bookable','price',array('id'=>$bookable_id));
}

/**
 * Find a list of days within a date range (inclusive).
 *
 * @param  integer	Day (start).
 * @param  integer	Month (start).
 * @param  integer	Year (start).
 * @param  integer	Day (end).
 * @param  integer	Month (end).
 * @param  integer	Year (end).
 * @return array		List of days.
 */
function days_in_range($start_day,$start_month,$start_year,$end_day,$end_month,$end_year)
{
	$start_date=mktime(0,0,0,$start_month,$start_day,$start_year);
	$end_date=mktime(0,0,0,$end_month,$end_day,$end_year);

	$days=array();
	$days[]=array(intval(date('d',$start_date)),intval(date('m',$start_date)),intval(date('Y',$start_date)));

	$current_date=$start_date;
	while($current_date<$end_date)
	{
		$current_date=strtotime('+1 day',$current_date);
		$days[]=array(intval(date('d',$current_date)),intval(date('m',$current_date)),intval(date('Y',$current_date)));
	}

	return $days;
}

/**
 * Finds whether a particular booking date is available for a particular bookable.
 *
 * @param  AUTO_LINK	Bookable.
 * @param  integer	Day.
 * @param  integer	Month.
 * @param  integer	Year.
 * @param  integer	Quantity needed.
 * @return ?tempcode	Error message (NULL: no issue).
 */
function booking_date_available($bookable_id,$day,$month,$year,$quantity)
{
	$asked=mktime(0,0,0,$month,$day,$year);

	// Check bookable exists
	$_bookable_row=$GLOBALS['SITE_DB']->query_select('bookable',array('*'),array('id'=>$bookable_id),'',1);
	if (!array_key_exists(0,$_bookable_row)) return do_lang_tempcode('INTERNAL_ERROR');
	$bookable_row=$_bookable_row[0];
	$codes_in_total=$GLOBALS['SITE_DB']->query_value('bookable_codes','COUNT(*)',array('bookable_id'=>$bookable_id));

	// Check bookable enabled
	if ($bookable_row['enabled']==0) return do_lang_tempcode('INTERNAL_ERROR');

	// Check bookable time is in active period
	$from=mktime(0,0,0,$bookable_row['active_from_month'],$bookable_row['active_from_day'],$bookable_row['active_from_year']);
	if ($asked<$from) return do_lang_tempcode('BOOKING_IMPOSSIBLE_NOT_STARTED',escape_html(get_timezoned_date($from,false)));
	if (!is_null($bookable_row['active_to_month']))
	{
		$to=mktime(0,0,0,$bookable_row['active_to_month'],$bookable_row['active_to_day'],$bookable_row['active_to_year']);
		if ($asked>=$to) return do_lang_tempcode('BOOKING_IMPOSSIBLE_ENDED',escape_html(get_timezoned_date($to,false)));
	}

	// Check bookable is not blacked for time
	$blacks=$GLOBALS['SITE_DB']->query_select('bookable_blacked',array('*'),array('bookable_id'=>$bookable_id));
	foreach ($blacks as $black)
	{
		$from=mktime(0,0,0,$bookable_row['blacked_from_month'],$bookable_row['blacked_from_day'],$bookable_row['blacked_from_year']);
		$to=mktime(0,0,0,$bookable_row['blacked_to_month'],$bookable_row['blacked_to_day'],$bookable_row['blacked_to_year']);
		if (($asked>=$from) && ($asked<$to))
		{
			if ($from==$to)
			{
				do_lang_tempcode('BOOKING_IMPOSSIBLE_BLACKED_ONEOFF',escape_html(get_timezoned_date($from,false),escape_html(get_translated_text($bookable_row['blacked_explanation']))));
			} else
			{
				do_lang_tempcode('BOOKING_IMPOSSIBLE_BLACKED_PERIOD',escape_html(get_timezoned_date($from,false),escape_html(get_timezoned_date($to,false),escape_html(get_translated_text($bookable_row['blacked_explanation']))));
			}
		}
	}

	// Check no overlap
	$map=array(
		'day'=>$day,
		'month'=>$month,
		'year'=>$year,
	);
	$codes_taken_already=$GLOBALS['SITE_DB']->query_value_null_ok('booking','COUNT(*)',array('day','month','year'),$map);
	if (count($codes_taken_already)+$quantity>$codes_in_total) return do_lang_tempcode('BOOKING_IMPOSSIBLE_FULL');

	// Good!
	return NULL;
}

/**
 * Send out booking mails.
 *
 * @param  array		Booking details structure.
 */
function send_booking_emails($request)
{
	require_code('mail');

	$customer_email=$GLOBALS['FORUM_DRIVER']->get_member_email_address(get_member());
	$customer_name=$GLOBALS['FORUM_DRIVER']->get_username(get_member());

	// Send receipt to customer
	$receipt=do_template('BOOKING_CONFIRM_FCOMCODE',array('REQUEST'=>$request));
	mail_wrap(do_lang('SUBJECT_BOOKING_CONFIRM',get_site_name()),static_evaluate_tempcode($receipt),$customer_email,$customer_name);

	// Send notice to staff
	$notice=do_template('BOOKING_NOTICE_FCOMCODE',array('REQUEST'=>$request,'MEMBER_ID'=>strval(get_member())));
	mail_wrap(do_lang('SUBJECT_BOOKING_NOTICE',$GLOBALS['FORUM_DRIVER']->get_username(get_member()),get_site_name()),static_evaluate_tempcode($notice),NULL,NULL,'','',2);
}
