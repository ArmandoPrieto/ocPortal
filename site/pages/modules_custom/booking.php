<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2011

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		booking
 */

/**
 * Module page class.
 */
class Module_booking
{

	/**
	 * Standard modular info function.
	 *
	 * @return ?array	Map of module info (NULL: module is disabled).
	 */
	function info()
	{
		$info=array();
		$info['author']='Chris Graham';
		$info['organisation']='ocProducts';
		$info['hacked_by']=NULL;
		$info['hack_version']=NULL;
		$info['version']=1;
		$info['locked']=false;
		return $info;
	}
	
	/**
	 * Standard modular uninstall function.
	 */
	function uninstall()
	{
		$GLOBALS['SITE_DB']->drop_if_exists('bookable');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_blacked');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_codes');
		$GLOBALS['SITE_DB']->drop_if_exists('booking');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_supplement');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_supplement_for');
		$GLOBALS['SITE_DB']->drop_if_exists('booking_supplement');
	}

	/**
	 * Standard modular install function.
	 *
	 * @param  ?integer	What version we're upgrading from (NULL: new install)
	 * @param  ?integer	What hack version we're upgrading from (NULL: new-install/not-upgrading-from-a-hacked-version)
	 */
	function install($upgrade_from=NULL,$upgrade_from_hack=NULL)
	{
		$GLOBALS['SITE_DB']->create_table('bookable',array(
			'id'=>'*AUTO',
			//'num_available'=>'INTEGER',		Implied by number of bookable_codes attached to bookable_id
			'title'=>'SHORT_TRANS',
			'description'=>'LONG_TRANS',
			'price'=>'REAL',
			'categorisation'=>'SHORT_TRANS', // (will work as a heading, for the booking form)
			'cycle_type'=>'ID_TEXT', // (same as event recurrences in the calendar addon; can be none) - a room cycles daily for example
			'cycle_pattern'=>'SHORT_TEXT',
			'user_may_choose_code'=>'BINARY',
			'supports_notes'=>'BINARY',
			'dates_are_ranges'=>'BINARY', // (if not, will only ask for a single date)
			'calendar_type'=>'?AUTO_LINK', // (this is auto-added and synched on edits; type has no perms by default)
			'add_date'=>'TIME',
			'edit_date'=>'?TIME',
			'submitter'=>'USER',

			'enabled'=>'BINARY',

			// (useful for defining seasonable bookables- e.g. summer bookable costing more, or with more rooms)
			'active_from_day'=>'SHORT_INTEGER',
			'active_from_month'=>'SHORT_INTEGER',
			'active_from_year'=>'SHORT_INTEGER',
			'active_to_day'=>'?SHORT_INTEGER',
			'active_to_month'=>'?SHORT_INTEGER',
			'active_to_year'=>'?SHORT_INTEGER',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_blacked',array(
			'id'=>'*AUTO',
			'bookable_id'=>'AUTO_LINK',
			'blacked_from_day'=>'SHORT_INTEGER',
			'blacked_from_month'=>'SHORT_INTEGER',
			'blacked_from_year'=>'SHORT_INTEGER',
			'blacked_to_day'=>'SHORT_INTEGER',
			'blacked_to_month'=>'SHORT_INTEGER',
			'blacked_to_year'=>'SHORT_INTEGER',
			'blacked_explanation'=>'LONG_TRANS',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_codes',array(
			'bookable_id'=>'*AUTO_LINK',
			'code'=>'*ID_TEXT', // (room numbers, seats, etc) ; can be auto-generated if requested
		));

		$GLOBALS['SITE_DB']->create_table('bookable_supplement',array(
			'id'=>'*AUTO',
			'price'=>'REAL',
			'price_is_per_period'=>'BINARY', // If this is the case, the supplement will actually be repeated out in separate records, each tied to a booking for that date
			'supports_quantities'=>'BINARY',
			'title'=>'SHORT_TRANS',
			'promo_code'=>'ID_TEXT', // If non-blank, the user must enter this promo-code to purchase this
			'supports_notes'=>'BINARY',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_supplement_for',array(
			'supplement_id'=>'*AUTO_LINK',
			'bookable_id'=>'*AUTO_LINK',
		));

		$GLOBALS['SITE_DB']->create_table('booking',array(
			'id'=>'*AUTO',
			'bookable_id'=>'AUTO_LINK',
			'member_id'=>'USER',
			'day'=>'SHORT_INTEGER',
			'month'=>'SHORT_INTEGER',
			'year'=>'SHORT_INTEGER',
			'code_allocation'=>'ID_TEXT', // These code allocations will be given out arbitrarily, which means later on if things get busy, things could be suboptimal (e.g. people's 'stay' split across different codes on different dates, whilst reorganising could solve that). So a human would probably reorganise this manually in some cases, and it should not be considered a real-world guarantee, or a necessary thing to make sure people get a full run-length on a single code
			'notes'=>'LONG_TEXT',
			'booked_at'=>'TIME', // time booking was made
			'paid_at'=>'?TIME',
			'paid_trans_id'=>'?AUTO_LINK',
		));

		$GLOBALS['SITE_DB']->create_table('booking_supplement',array(
			'booking_id'=>'*AUTO_LINK',
			'supplement_id'=>'*AUTO_LINK',
			'quantity'=>'INTEGER',
			'notes'=>'LONG_TEXT',
		));
	}

	/**
	 * Standard modular entry-point finder function.
	 *
	 * @return ?array	A map of entry points (type-code=>language-code) (NULL: disabled).
	 */
	function get_entry_points()
	{
		// TODO
	}

	/**
	 * Standard modular page-link finder function (does not return the main entry-points that are not inside the tree).
	 *
	 * @param  ?integer  The number of tree levels to computer (NULL: no limit)
	 * @param  boolean	Whether to not return stuff that does not support permissions (unless it is underneath something that does).
	 * @param  ?string	Position to start at in the tree. Does not need to be respected. (NULL: from root)
	 * @param  boolean	Whether to avoid returning categories.
	 * @return ?array	 	A tuple: 1) full tree structure [made up of (pagelink, permission-module, permissions-id, title, children, ?entry point for the children, ?children permission module, ?whether there are children) OR a list of maps from a get_* function] 2) permissions-page 3) optional base entry-point for the tree 4) optional permission-module 5) optional permissions-id (NULL: disabled).
	 */
	function get_page_links($max_depth=NULL,$require_permission_support=false,$start_at=NULL,$dont_care_about_categories=false)
	{
		// TODO
	}

	/**
	 * Standard modular new-style deep page-link finder function (does not return the main entry-points).
	 *
	 * @param  string  	Callback function to send discovered page-links to.
	 * @param  MEMBER		The member we are finding stuff for (we only find what the member can view).
	 * @param  integer	Code for how deep we are tunnelling down, in terms of whether we are getting entries as well as categories.
	 * @param  string		Stub used to create page-links. This is passed in because we don't want to assume a zone or page name within this function.
	 * @param  ?string	Where we're looking under (NULL: root of tree). We typically will NOT show a root node as there's often already an entry-point representing it.
	 * @param  integer	Our recursion depth (used to calculate importance of page-link, used for instance by Google sitemap). Deeper is typically less important.
	 * @param  ?array		Non-standard for API [extra parameter tacked on] (NULL: yet unknown). Contents of database table for performance.
	 * @param  ?array		Non-standard for API [extra parameter tacked on] (NULL: yet unknown). Contents of database table for performance.
	 */
	function get_sitemap_pagelinks($callback,$member_id,$depth,$pagelink_stub,$parent_pagelink=NULL,$recurse_level=0,$category_data=NULL,$entry_data=NULL)
	{
		// TODO
	}

	/**
	 * Standard modular run function.
	 *
	 * @return tempcode	The result of execution.
	 */
	function run()
	{
		require_lang('booking');

		$type=get_param('type','misc');

		// Decide what to do
		if ($type=='misc') return $this->choose_bookables_and_dates(); // This may be skipped, if blocks were used to access // TODO // TODO Make sure date selectors user friendly (yahoo widget, and sensible end date defaults when start date changed) // TODO: only pick available ones! // TODO: Filter for defining what is shown // Show notes about closed times // UI must be courteous if dates not available
		if ($type=='account') return $this->create_account_or_login(); // TODO (redirects to next if logged in)
		if ($type=='done') return $this->thanks(); // TODO (emails staff and receipt notice to user, and saves everything)

		return new ocp_tempcode();
	}

}

/*

TODO (for future expansion, not critical base functionality)...

Implement online payment support; will need nice way to remove unpaid bookings in future too

Implement permissions for bookables

Manual choice of codes (seats or whatever)

Implement support for the defined cycle patterns (currently just daily or none)

What if we want to run on a reduced capacity for a period?

*/
